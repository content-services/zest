/*
Pulp 3 API

Fetch, Upload, Organize, and Distribute Software Packages

API version: v3
Contact: pulp-list@redhat.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pulpGoBinding

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
	"reflect"
)


// TasksApiService TasksApi service
type TasksApiService service

type TasksApiTasksAddRoleRequest struct {
	ctx context.Context
	ApiService *TasksApiService
	taskHref string
	nestedRole *NestedRole
}

func (r TasksApiTasksAddRoleRequest) NestedRole(nestedRole NestedRole) TasksApiTasksAddRoleRequest {
	r.nestedRole = &nestedRole
	return r
}

func (r TasksApiTasksAddRoleRequest) Execute() (*NestedRoleResponse, *http.Response, error) {
	return r.ApiService.TasksAddRoleExecute(r)
}

/*
TasksAddRole Method for TasksAddRole

Add a role for this object to users/groups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskHref
 @return TasksApiTasksAddRoleRequest
*/
func (a *TasksApiService) TasksAddRole(ctx context.Context, taskHref string) TasksApiTasksAddRoleRequest {
	return TasksApiTasksAddRoleRequest{
		ApiService: a,
		ctx: ctx,
		taskHref: taskHref,
	}
}

// Execute executes the request
//  @return NestedRoleResponse
func (a *TasksApiService) TasksAddRoleExecute(r TasksApiTasksAddRoleRequest) (*NestedRoleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NestedRoleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.TasksAddRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{task_href}add_role/"
	localVarPath = strings.Replace(localVarPath, "{"+"task_href"+"}", url.PathEscape(parameterValueToString(r.taskHref, "taskHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.nestedRole == nil {
		return localVarReturnValue, nil, reportError("nestedRole is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.nestedRole
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TasksApiTasksCancelRequest struct {
	ctx context.Context
	ApiService *TasksApiService
	taskHref string
	patchedTaskCancel *PatchedTaskCancel
}

func (r TasksApiTasksCancelRequest) PatchedTaskCancel(patchedTaskCancel PatchedTaskCancel) TasksApiTasksCancelRequest {
	r.patchedTaskCancel = &patchedTaskCancel
	return r
}

func (r TasksApiTasksCancelRequest) Execute() (*TaskResponse, *http.Response, error) {
	return r.ApiService.TasksCancelExecute(r)
}

/*
TasksCancel Cancel a task

This operation cancels a task.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskHref
 @return TasksApiTasksCancelRequest
*/
func (a *TasksApiService) TasksCancel(ctx context.Context, taskHref string) TasksApiTasksCancelRequest {
	return TasksApiTasksCancelRequest{
		ApiService: a,
		ctx: ctx,
		taskHref: taskHref,
	}
}

// Execute executes the request
//  @return TaskResponse
func (a *TasksApiService) TasksCancelExecute(r TasksApiTasksCancelRequest) (*TaskResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.TasksCancel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{task_href}"
	localVarPath = strings.Replace(localVarPath, "{"+"task_href"+"}", url.PathEscape(parameterValueToString(r.taskHref, "taskHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedTaskCancel == nil {
		return localVarReturnValue, nil, reportError("patchedTaskCancel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedTaskCancel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v TaskResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TasksApiTasksDeleteRequest struct {
	ctx context.Context
	ApiService *TasksApiService
	taskHref string
}

func (r TasksApiTasksDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.TasksDeleteExecute(r)
}

/*
TasksDelete Delete a task

A customized named ModelViewSet that knows how to register itself with the Pulp API router.

This viewset is discoverable by its name.
"Normal" Django Models and Master/Detail models are supported by the ``register_with`` method.

Attributes:
    lookup_field (str): The name of the field by which an object should be looked up, in
        addition to any parent lookups if this ViewSet is nested. Defaults to 'pk'
    endpoint_name (str): The name of the final path segment that should identify the ViewSet's
        collection endpoint.
    nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must
        correspond to the "parent_prefix" of a router with rest_framework_nested.NestedMixin.
        None indicates this ViewSet should not be nested.
    parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs
        to django model filter expressions that can be used with the corresponding value from
        self.kwargs, used only by a nested ViewSet to filter based on the parent object's
        identity.
    schema (DefaultSchema): The schema class to use by default in a viewset.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskHref
 @return TasksApiTasksDeleteRequest
*/
func (a *TasksApiService) TasksDelete(ctx context.Context, taskHref string) TasksApiTasksDeleteRequest {
	return TasksApiTasksDeleteRequest{
		ApiService: a,
		ctx: ctx,
		taskHref: taskHref,
	}
}

// Execute executes the request
func (a *TasksApiService) TasksDeleteExecute(r TasksApiTasksDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.TasksDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{task_href}"
	localVarPath = strings.Replace(localVarPath, "{"+"task_href"+"}", url.PathEscape(parameterValueToString(r.taskHref, "taskHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TasksApiTasksListRequest struct {
	ctx context.Context
	ApiService *TasksApiService
	childTasks *string
	createdResources *string
	exclusiveResources *string
	exclusiveResourcesIn *[]string
	finishedAt *time.Time
	finishedAtGt *time.Time
	finishedAtGte *time.Time
	finishedAtLt *time.Time
	finishedAtLte *time.Time
	finishedAtRange *[]time.Time
	limit *int32
	loggingCid *string
	loggingCidContains *string
	name *string
	nameContains *string
	nameIn *[]string
	offset *int32
	ordering *[]string
	parentTask *string
	reservedResources *string
	reservedResourcesIn *[]string
	reservedResourcesRecord *[]string
	sharedResources *string
	sharedResourcesIn *[]string
	startedAt *time.Time
	startedAtGt *time.Time
	startedAtGte *time.Time
	startedAtLt *time.Time
	startedAtLte *time.Time
	startedAtRange *[]time.Time
	state *string
	stateIn *[]string
	taskGroup *string
	worker *string
	workerIn *[]string
	fields *[]string
	excludeFields *[]string
}

// Filter results where child_tasks matches value
func (r TasksApiTasksListRequest) ChildTasks(childTasks string) TasksApiTasksListRequest {
	r.childTasks = &childTasks
	return r
}

func (r TasksApiTasksListRequest) CreatedResources(createdResources string) TasksApiTasksListRequest {
	r.createdResources = &createdResources
	return r
}

func (r TasksApiTasksListRequest) ExclusiveResources(exclusiveResources string) TasksApiTasksListRequest {
	r.exclusiveResources = &exclusiveResources
	return r
}

// Multiple values may be separated by commas.
func (r TasksApiTasksListRequest) ExclusiveResourcesIn(exclusiveResourcesIn []string) TasksApiTasksListRequest {
	r.exclusiveResourcesIn = &exclusiveResourcesIn
	return r
}

// Filter results where finished_at matches value
func (r TasksApiTasksListRequest) FinishedAt(finishedAt time.Time) TasksApiTasksListRequest {
	r.finishedAt = &finishedAt
	return r
}

// Filter results where finished_at is greater than value
func (r TasksApiTasksListRequest) FinishedAtGt(finishedAtGt time.Time) TasksApiTasksListRequest {
	r.finishedAtGt = &finishedAtGt
	return r
}

// Filter results where finished_at is greater than or equal to value
func (r TasksApiTasksListRequest) FinishedAtGte(finishedAtGte time.Time) TasksApiTasksListRequest {
	r.finishedAtGte = &finishedAtGte
	return r
}

// Filter results where finished_at is less than value
func (r TasksApiTasksListRequest) FinishedAtLt(finishedAtLt time.Time) TasksApiTasksListRequest {
	r.finishedAtLt = &finishedAtLt
	return r
}

// Filter results where finished_at is less than or equal to value
func (r TasksApiTasksListRequest) FinishedAtLte(finishedAtLte time.Time) TasksApiTasksListRequest {
	r.finishedAtLte = &finishedAtLte
	return r
}

// Filter results where finished_at is between two comma separated values
func (r TasksApiTasksListRequest) FinishedAtRange(finishedAtRange []time.Time) TasksApiTasksListRequest {
	r.finishedAtRange = &finishedAtRange
	return r
}

// Number of results to return per page.
func (r TasksApiTasksListRequest) Limit(limit int32) TasksApiTasksListRequest {
	r.limit = &limit
	return r
}

// Filter results where logging_cid matches value
func (r TasksApiTasksListRequest) LoggingCid(loggingCid string) TasksApiTasksListRequest {
	r.loggingCid = &loggingCid
	return r
}

// Filter results where logging_cid contains value
func (r TasksApiTasksListRequest) LoggingCidContains(loggingCidContains string) TasksApiTasksListRequest {
	r.loggingCidContains = &loggingCidContains
	return r
}

// Filter results where name matches value
func (r TasksApiTasksListRequest) Name(name string) TasksApiTasksListRequest {
	r.name = &name
	return r
}

// Filter results where name contains value
func (r TasksApiTasksListRequest) NameContains(nameContains string) TasksApiTasksListRequest {
	r.nameContains = &nameContains
	return r
}

// Filter results where name is in a comma-separated list of values
func (r TasksApiTasksListRequest) NameIn(nameIn []string) TasksApiTasksListRequest {
	r.nameIn = &nameIn
	return r
}

// The initial index from which to return the results.
func (r TasksApiTasksListRequest) Offset(offset int32) TasksApiTasksListRequest {
	r.offset = &offset
	return r
}

// Ordering
func (r TasksApiTasksListRequest) Ordering(ordering []string) TasksApiTasksListRequest {
	r.ordering = &ordering
	return r
}

// Filter results where parent_task matches value
func (r TasksApiTasksListRequest) ParentTask(parentTask string) TasksApiTasksListRequest {
	r.parentTask = &parentTask
	return r
}

func (r TasksApiTasksListRequest) ReservedResources(reservedResources string) TasksApiTasksListRequest {
	r.reservedResources = &reservedResources
	return r
}

// Multiple values may be separated by commas.
func (r TasksApiTasksListRequest) ReservedResourcesIn(reservedResourcesIn []string) TasksApiTasksListRequest {
	r.reservedResourcesIn = &reservedResourcesIn
	return r
}

func (r TasksApiTasksListRequest) ReservedResourcesRecord(reservedResourcesRecord []string) TasksApiTasksListRequest {
	r.reservedResourcesRecord = &reservedResourcesRecord
	return r
}

func (r TasksApiTasksListRequest) SharedResources(sharedResources string) TasksApiTasksListRequest {
	r.sharedResources = &sharedResources
	return r
}

// Multiple values may be separated by commas.
func (r TasksApiTasksListRequest) SharedResourcesIn(sharedResourcesIn []string) TasksApiTasksListRequest {
	r.sharedResourcesIn = &sharedResourcesIn
	return r
}

// Filter results where started_at matches value
func (r TasksApiTasksListRequest) StartedAt(startedAt time.Time) TasksApiTasksListRequest {
	r.startedAt = &startedAt
	return r
}

// Filter results where started_at is greater than value
func (r TasksApiTasksListRequest) StartedAtGt(startedAtGt time.Time) TasksApiTasksListRequest {
	r.startedAtGt = &startedAtGt
	return r
}

// Filter results where started_at is greater than or equal to value
func (r TasksApiTasksListRequest) StartedAtGte(startedAtGte time.Time) TasksApiTasksListRequest {
	r.startedAtGte = &startedAtGte
	return r
}

// Filter results where started_at is less than value
func (r TasksApiTasksListRequest) StartedAtLt(startedAtLt time.Time) TasksApiTasksListRequest {
	r.startedAtLt = &startedAtLt
	return r
}

// Filter results where started_at is less than or equal to value
func (r TasksApiTasksListRequest) StartedAtLte(startedAtLte time.Time) TasksApiTasksListRequest {
	r.startedAtLte = &startedAtLte
	return r
}

// Filter results where started_at is between two comma separated values
func (r TasksApiTasksListRequest) StartedAtRange(startedAtRange []time.Time) TasksApiTasksListRequest {
	r.startedAtRange = &startedAtRange
	return r
}

// Filter results where state matches value
func (r TasksApiTasksListRequest) State(state string) TasksApiTasksListRequest {
	r.state = &state
	return r
}

// Filter results where state is in a comma-separated list of values
func (r TasksApiTasksListRequest) StateIn(stateIn []string) TasksApiTasksListRequest {
	r.stateIn = &stateIn
	return r
}

// Filter results where task_group matches value
func (r TasksApiTasksListRequest) TaskGroup(taskGroup string) TasksApiTasksListRequest {
	r.taskGroup = &taskGroup
	return r
}

// Filter results where worker matches value
func (r TasksApiTasksListRequest) Worker(worker string) TasksApiTasksListRequest {
	r.worker = &worker
	return r
}

// Filter results where worker is in a comma-separated list of values
func (r TasksApiTasksListRequest) WorkerIn(workerIn []string) TasksApiTasksListRequest {
	r.workerIn = &workerIn
	return r
}

// A list of fields to include in the response.
func (r TasksApiTasksListRequest) Fields(fields []string) TasksApiTasksListRequest {
	r.fields = &fields
	return r
}

// A list of fields to exclude from the response.
func (r TasksApiTasksListRequest) ExcludeFields(excludeFields []string) TasksApiTasksListRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r TasksApiTasksListRequest) Execute() (*PaginatedTaskResponseList, *http.Response, error) {
	return r.ApiService.TasksListExecute(r)
}

/*
TasksList List tasks

A customized named ModelViewSet that knows how to register itself with the Pulp API router.

This viewset is discoverable by its name.
"Normal" Django Models and Master/Detail models are supported by the ``register_with`` method.

Attributes:
    lookup_field (str): The name of the field by which an object should be looked up, in
        addition to any parent lookups if this ViewSet is nested. Defaults to 'pk'
    endpoint_name (str): The name of the final path segment that should identify the ViewSet's
        collection endpoint.
    nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must
        correspond to the "parent_prefix" of a router with rest_framework_nested.NestedMixin.
        None indicates this ViewSet should not be nested.
    parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs
        to django model filter expressions that can be used with the corresponding value from
        self.kwargs, used only by a nested ViewSet to filter based on the parent object's
        identity.
    schema (DefaultSchema): The schema class to use by default in a viewset.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TasksApiTasksListRequest
*/
func (a *TasksApiService) TasksList(ctx context.Context) TasksApiTasksListRequest {
	return TasksApiTasksListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedTaskResponseList
func (a *TasksApiService) TasksListExecute(r TasksApiTasksListRequest) (*PaginatedTaskResponseList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedTaskResponseList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.TasksList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/tasks/"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.childTasks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "child_tasks", r.childTasks, "")
	}
	if r.createdResources != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_resources", r.createdResources, "")
	}
	if r.exclusiveResources != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclusive_resources", r.exclusiveResources, "")
	}
	if r.exclusiveResourcesIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclusive_resources__in", r.exclusiveResourcesIn, "csv")
	}
	if r.finishedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "finished_at", r.finishedAt, "")
	}
	if r.finishedAtGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "finished_at__gt", r.finishedAtGt, "")
	}
	if r.finishedAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "finished_at__gte", r.finishedAtGte, "")
	}
	if r.finishedAtLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "finished_at__lt", r.finishedAtLt, "")
	}
	if r.finishedAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "finished_at__lte", r.finishedAtLte, "")
	}
	if r.finishedAtRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "finished_at__range", r.finishedAtRange, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.loggingCid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "logging_cid", r.loggingCid, "")
	}
	if r.loggingCidContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "logging_cid__contains", r.loggingCidContains, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.nameContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__contains", r.nameContains, "")
	}
	if r.nameIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__in", r.nameIn, "csv")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "csv")
	}
	if r.parentTask != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_task", r.parentTask, "")
	}
	if r.reservedResources != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reserved_resources", r.reservedResources, "")
	}
	if r.reservedResourcesIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reserved_resources__in", r.reservedResourcesIn, "csv")
	}
	if r.reservedResourcesRecord != nil {
		t := *r.reservedResourcesRecord
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "reserved_resources_record", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "reserved_resources_record", t, "multi")
		}
	}
	if r.sharedResources != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shared_resources", r.sharedResources, "")
	}
	if r.sharedResourcesIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shared_resources__in", r.sharedResourcesIn, "csv")
	}
	if r.startedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "started_at", r.startedAt, "")
	}
	if r.startedAtGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "started_at__gt", r.startedAtGt, "")
	}
	if r.startedAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "started_at__gte", r.startedAtGte, "")
	}
	if r.startedAtLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "started_at__lt", r.startedAtLt, "")
	}
	if r.startedAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "started_at__lte", r.startedAtLte, "")
	}
	if r.startedAtRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "started_at__range", r.startedAtRange, "csv")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.stateIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state__in", r.stateIn, "csv")
	}
	if r.taskGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "task_group", r.taskGroup, "")
	}
	if r.worker != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "worker", r.worker, "")
	}
	if r.workerIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "worker__in", r.workerIn, "csv")
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.excludeFields != nil {
		t := *r.excludeFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TasksApiTasksListRolesRequest struct {
	ctx context.Context
	ApiService *TasksApiService
	taskHref string
	fields *[]string
	excludeFields *[]string
}

// A list of fields to include in the response.
func (r TasksApiTasksListRolesRequest) Fields(fields []string) TasksApiTasksListRolesRequest {
	r.fields = &fields
	return r
}

// A list of fields to exclude from the response.
func (r TasksApiTasksListRolesRequest) ExcludeFields(excludeFields []string) TasksApiTasksListRolesRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r TasksApiTasksListRolesRequest) Execute() (*ObjectRolesResponse, *http.Response, error) {
	return r.ApiService.TasksListRolesExecute(r)
}

/*
TasksListRoles Method for TasksListRoles

List roles assigned to this object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskHref
 @return TasksApiTasksListRolesRequest
*/
func (a *TasksApiService) TasksListRoles(ctx context.Context, taskHref string) TasksApiTasksListRolesRequest {
	return TasksApiTasksListRolesRequest{
		ApiService: a,
		ctx: ctx,
		taskHref: taskHref,
	}
}

// Execute executes the request
//  @return ObjectRolesResponse
func (a *TasksApiService) TasksListRolesExecute(r TasksApiTasksListRolesRequest) (*ObjectRolesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectRolesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.TasksListRoles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{task_href}list_roles/"
	localVarPath = strings.Replace(localVarPath, "{"+"task_href"+"}", url.PathEscape(parameterValueToString(r.taskHref, "taskHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.excludeFields != nil {
		t := *r.excludeFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TasksApiTasksMyPermissionsRequest struct {
	ctx context.Context
	ApiService *TasksApiService
	taskHref string
	fields *[]string
	excludeFields *[]string
}

// A list of fields to include in the response.
func (r TasksApiTasksMyPermissionsRequest) Fields(fields []string) TasksApiTasksMyPermissionsRequest {
	r.fields = &fields
	return r
}

// A list of fields to exclude from the response.
func (r TasksApiTasksMyPermissionsRequest) ExcludeFields(excludeFields []string) TasksApiTasksMyPermissionsRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r TasksApiTasksMyPermissionsRequest) Execute() (*MyPermissionsResponse, *http.Response, error) {
	return r.ApiService.TasksMyPermissionsExecute(r)
}

/*
TasksMyPermissions Method for TasksMyPermissions

List permissions available to the current user on this object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskHref
 @return TasksApiTasksMyPermissionsRequest
*/
func (a *TasksApiService) TasksMyPermissions(ctx context.Context, taskHref string) TasksApiTasksMyPermissionsRequest {
	return TasksApiTasksMyPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		taskHref: taskHref,
	}
}

// Execute executes the request
//  @return MyPermissionsResponse
func (a *TasksApiService) TasksMyPermissionsExecute(r TasksApiTasksMyPermissionsRequest) (*MyPermissionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MyPermissionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.TasksMyPermissions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{task_href}my_permissions/"
	localVarPath = strings.Replace(localVarPath, "{"+"task_href"+"}", url.PathEscape(parameterValueToString(r.taskHref, "taskHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.excludeFields != nil {
		t := *r.excludeFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TasksApiTasksPurgeRequest struct {
	ctx context.Context
	ApiService *TasksApiService
	purge *Purge
}

func (r TasksApiTasksPurgeRequest) Purge(purge Purge) TasksApiTasksPurgeRequest {
	r.purge = &purge
	return r
}

func (r TasksApiTasksPurgeRequest) Execute() (*AsyncOperationResponse, *http.Response, error) {
	return r.ApiService.TasksPurgeExecute(r)
}

/*
TasksPurge Purge Completed Tasks

Trigger an asynchronous task that deletes completed tasks that finished prior to a specified timestamp (tech-preview, may change in the future).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TasksApiTasksPurgeRequest
*/
func (a *TasksApiService) TasksPurge(ctx context.Context) TasksApiTasksPurgeRequest {
	return TasksApiTasksPurgeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AsyncOperationResponse
func (a *TasksApiService) TasksPurgeExecute(r TasksApiTasksPurgeRequest) (*AsyncOperationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncOperationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.TasksPurge")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/tasks/purge/"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.purge == nil {
		return localVarReturnValue, nil, reportError("purge is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.purge
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TasksApiTasksReadRequest struct {
	ctx context.Context
	ApiService *TasksApiService
	taskHref string
	fields *[]string
	excludeFields *[]string
}

// A list of fields to include in the response.
func (r TasksApiTasksReadRequest) Fields(fields []string) TasksApiTasksReadRequest {
	r.fields = &fields
	return r
}

// A list of fields to exclude from the response.
func (r TasksApiTasksReadRequest) ExcludeFields(excludeFields []string) TasksApiTasksReadRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r TasksApiTasksReadRequest) Execute() (*TaskResponse, *http.Response, error) {
	return r.ApiService.TasksReadExecute(r)
}

/*
TasksRead Inspect a task

A customized named ModelViewSet that knows how to register itself with the Pulp API router.

This viewset is discoverable by its name.
"Normal" Django Models and Master/Detail models are supported by the ``register_with`` method.

Attributes:
    lookup_field (str): The name of the field by which an object should be looked up, in
        addition to any parent lookups if this ViewSet is nested. Defaults to 'pk'
    endpoint_name (str): The name of the final path segment that should identify the ViewSet's
        collection endpoint.
    nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must
        correspond to the "parent_prefix" of a router with rest_framework_nested.NestedMixin.
        None indicates this ViewSet should not be nested.
    parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs
        to django model filter expressions that can be used with the corresponding value from
        self.kwargs, used only by a nested ViewSet to filter based on the parent object's
        identity.
    schema (DefaultSchema): The schema class to use by default in a viewset.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskHref
 @return TasksApiTasksReadRequest
*/
func (a *TasksApiService) TasksRead(ctx context.Context, taskHref string) TasksApiTasksReadRequest {
	return TasksApiTasksReadRequest{
		ApiService: a,
		ctx: ctx,
		taskHref: taskHref,
	}
}

// Execute executes the request
//  @return TaskResponse
func (a *TasksApiService) TasksReadExecute(r TasksApiTasksReadRequest) (*TaskResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.TasksRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{task_href}"
	localVarPath = strings.Replace(localVarPath, "{"+"task_href"+"}", url.PathEscape(parameterValueToString(r.taskHref, "taskHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.excludeFields != nil {
		t := *r.excludeFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TasksApiTasksRemoveRoleRequest struct {
	ctx context.Context
	ApiService *TasksApiService
	taskHref string
	nestedRole *NestedRole
}

func (r TasksApiTasksRemoveRoleRequest) NestedRole(nestedRole NestedRole) TasksApiTasksRemoveRoleRequest {
	r.nestedRole = &nestedRole
	return r
}

func (r TasksApiTasksRemoveRoleRequest) Execute() (*NestedRoleResponse, *http.Response, error) {
	return r.ApiService.TasksRemoveRoleExecute(r)
}

/*
TasksRemoveRole Method for TasksRemoveRole

Remove a role for this object from users/groups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskHref
 @return TasksApiTasksRemoveRoleRequest
*/
func (a *TasksApiService) TasksRemoveRole(ctx context.Context, taskHref string) TasksApiTasksRemoveRoleRequest {
	return TasksApiTasksRemoveRoleRequest{
		ApiService: a,
		ctx: ctx,
		taskHref: taskHref,
	}
}

// Execute executes the request
//  @return NestedRoleResponse
func (a *TasksApiService) TasksRemoveRoleExecute(r TasksApiTasksRemoveRoleRequest) (*NestedRoleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NestedRoleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.TasksRemoveRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{task_href}remove_role/"
	localVarPath = strings.Replace(localVarPath, "{"+"task_href"+"}", url.PathEscape(parameterValueToString(r.taskHref, "taskHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.nestedRole == nil {
		return localVarReturnValue, nil, reportError("nestedRole is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.nestedRole
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
