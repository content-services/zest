/*
Pulp 3 API

Fetch, Upload, Organize, and Distribute Software Packages

API version: v3
Contact: pulp-list@redhat.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pulpGoBinding

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
	"reflect"
)


// RepositoriesContainerApiService RepositoriesContainerApi service
type RepositoriesContainerApiService service

type RepositoriesContainerApiRepositoriesContainerContainerAddRequest struct {
	ctx context.Context
	ApiService *RepositoriesContainerApiService
	containerContainerRepositoryHref string
	recursiveManage *RecursiveManage
}

func (r RepositoriesContainerApiRepositoriesContainerContainerAddRequest) RecursiveManage(recursiveManage RecursiveManage) RepositoriesContainerApiRepositoriesContainerContainerAddRequest {
	r.recursiveManage = &recursiveManage
	return r
}

func (r RepositoriesContainerApiRepositoriesContainerContainerAddRequest) Execute() (*AsyncOperationResponse, *http.Response, error) {
	return r.ApiService.RepositoriesContainerContainerAddExecute(r)
}

/*
RepositoriesContainerContainerAdd Add content

Trigger an asynchronous task to recursively add container content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerContainerRepositoryHref
 @return RepositoriesContainerApiRepositoriesContainerContainerAddRequest
*/
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerAdd(ctx context.Context, containerContainerRepositoryHref string) RepositoriesContainerApiRepositoriesContainerContainerAddRequest {
	return RepositoriesContainerApiRepositoriesContainerContainerAddRequest{
		ApiService: a,
		ctx: ctx,
		containerContainerRepositoryHref: containerContainerRepositoryHref,
	}
}

// Execute executes the request
//  @return AsyncOperationResponse
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerAddExecute(r RepositoriesContainerApiRepositoriesContainerContainerAddRequest) (*AsyncOperationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncOperationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoriesContainerApiService.RepositoriesContainerContainerAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{container_container_repository_href}add/"
	localVarPath = strings.Replace(localVarPath, "{"+"container_container_repository_href"+"}", url.PathEscape(parameterValueToString(r.containerContainerRepositoryHref, "containerContainerRepositoryHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.recursiveManage == nil {
		return localVarReturnValue, nil, reportError("recursiveManage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.recursiveManage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RepositoriesContainerApiRepositoriesContainerContainerAddRoleRequest struct {
	ctx context.Context
	ApiService *RepositoriesContainerApiService
	containerContainerRepositoryHref string
	nestedRole *NestedRole
}

func (r RepositoriesContainerApiRepositoriesContainerContainerAddRoleRequest) NestedRole(nestedRole NestedRole) RepositoriesContainerApiRepositoriesContainerContainerAddRoleRequest {
	r.nestedRole = &nestedRole
	return r
}

func (r RepositoriesContainerApiRepositoriesContainerContainerAddRoleRequest) Execute() (*NestedRoleResponse, *http.Response, error) {
	return r.ApiService.RepositoriesContainerContainerAddRoleExecute(r)
}

/*
RepositoriesContainerContainerAddRole Method for RepositoriesContainerContainerAddRole

Add a role for this object to users/groups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerContainerRepositoryHref
 @return RepositoriesContainerApiRepositoriesContainerContainerAddRoleRequest
*/
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerAddRole(ctx context.Context, containerContainerRepositoryHref string) RepositoriesContainerApiRepositoriesContainerContainerAddRoleRequest {
	return RepositoriesContainerApiRepositoriesContainerContainerAddRoleRequest{
		ApiService: a,
		ctx: ctx,
		containerContainerRepositoryHref: containerContainerRepositoryHref,
	}
}

// Execute executes the request
//  @return NestedRoleResponse
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerAddRoleExecute(r RepositoriesContainerApiRepositoriesContainerContainerAddRoleRequest) (*NestedRoleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NestedRoleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoriesContainerApiService.RepositoriesContainerContainerAddRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{container_container_repository_href}add_role/"
	localVarPath = strings.Replace(localVarPath, "{"+"container_container_repository_href"+"}", url.PathEscape(parameterValueToString(r.containerContainerRepositoryHref, "containerContainerRepositoryHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.nestedRole == nil {
		return localVarReturnValue, nil, reportError("nestedRole is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.nestedRole
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RepositoriesContainerApiRepositoriesContainerContainerBuildImageRequest struct {
	ctx context.Context
	ApiService *RepositoriesContainerApiService
	containerContainerRepositoryHref string
	containerfileArtifact *string
	containerfile *os.File
	tag *string
	artifacts *map[string]interface{}
}

// Artifact representing the Containerfile that should be used to run podman-build.
func (r RepositoriesContainerApiRepositoriesContainerContainerBuildImageRequest) ContainerfileArtifact(containerfileArtifact string) RepositoriesContainerApiRepositoriesContainerContainerBuildImageRequest {
	r.containerfileArtifact = &containerfileArtifact
	return r
}

// An uploaded Containerfile that should be used to run podman-build.
func (r RepositoriesContainerApiRepositoriesContainerContainerBuildImageRequest) Containerfile(containerfile *os.File) RepositoriesContainerApiRepositoriesContainerContainerBuildImageRequest {
	r.containerfile = containerfile
	return r
}

// A tag name for the new image being built.
func (r RepositoriesContainerApiRepositoriesContainerContainerBuildImageRequest) Tag(tag string) RepositoriesContainerApiRepositoriesContainerContainerBuildImageRequest {
	r.tag = &tag
	return r
}

// A JSON string where each key is an artifact href and the value is it&#39;s relative path (name) inside the /pulp_working_directory of the build container executing the Containerfile.
func (r RepositoriesContainerApiRepositoriesContainerContainerBuildImageRequest) Artifacts(artifacts map[string]interface{}) RepositoriesContainerApiRepositoriesContainerContainerBuildImageRequest {
	r.artifacts = &artifacts
	return r
}

func (r RepositoriesContainerApiRepositoriesContainerContainerBuildImageRequest) Execute() (*AsyncOperationResponse, *http.Response, error) {
	return r.ApiService.RepositoriesContainerContainerBuildImageExecute(r)
}

/*
RepositoriesContainerContainerBuildImage Build an Image

Trigger an asynchronous task to build an OCI image from a Containerfile. A new repository version is created with the new image and tag. This API is tech preview in Pulp Container 1.1. Backwards compatibility when upgrading is not guaranteed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerContainerRepositoryHref
 @return RepositoriesContainerApiRepositoriesContainerContainerBuildImageRequest
*/
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerBuildImage(ctx context.Context, containerContainerRepositoryHref string) RepositoriesContainerApiRepositoriesContainerContainerBuildImageRequest {
	return RepositoriesContainerApiRepositoriesContainerContainerBuildImageRequest{
		ApiService: a,
		ctx: ctx,
		containerContainerRepositoryHref: containerContainerRepositoryHref,
	}
}

// Execute executes the request
//  @return AsyncOperationResponse
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerBuildImageExecute(r RepositoriesContainerApiRepositoriesContainerContainerBuildImageRequest) (*AsyncOperationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncOperationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoriesContainerApiService.RepositoriesContainerContainerBuildImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{container_container_repository_href}build_image/"
	localVarPath = strings.Replace(localVarPath, "{"+"container_container_repository_href"+"}", url.PathEscape(parameterValueToString(r.containerContainerRepositoryHref, "containerContainerRepositoryHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.containerfileArtifact != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "containerfile_artifact", r.containerfileArtifact, "")
	}
	var containerfileLocalVarFormFileName string
	var containerfileLocalVarFileName     string
	var containerfileLocalVarFileBytes    []byte

	containerfileLocalVarFormFileName = "containerfile"


	containerfileLocalVarFile := r.containerfile

	if containerfileLocalVarFile != nil {
		fbs, _ := io.ReadAll(containerfileLocalVarFile)

		containerfileLocalVarFileBytes = fbs
		containerfileLocalVarFileName = containerfileLocalVarFile.Name()
		containerfileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: containerfileLocalVarFileBytes, fileName: containerfileLocalVarFileName, formFileName: containerfileLocalVarFormFileName})
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "tag", r.tag, "")
	}
	if r.artifacts != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "artifacts", r.artifacts, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RepositoriesContainerApiRepositoriesContainerContainerCopyManifestsRequest struct {
	ctx context.Context
	ApiService *RepositoriesContainerApiService
	containerContainerRepositoryHref string
	manifestCopy *ManifestCopy
}

func (r RepositoriesContainerApiRepositoriesContainerContainerCopyManifestsRequest) ManifestCopy(manifestCopy ManifestCopy) RepositoriesContainerApiRepositoriesContainerContainerCopyManifestsRequest {
	r.manifestCopy = &manifestCopy
	return r
}

func (r RepositoriesContainerApiRepositoriesContainerContainerCopyManifestsRequest) Execute() (*AsyncOperationResponse, *http.Response, error) {
	return r.ApiService.RepositoriesContainerContainerCopyManifestsExecute(r)
}

/*
RepositoriesContainerContainerCopyManifests Copy manifests

Trigger an asynchronous task to copy manifests

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerContainerRepositoryHref
 @return RepositoriesContainerApiRepositoriesContainerContainerCopyManifestsRequest
*/
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerCopyManifests(ctx context.Context, containerContainerRepositoryHref string) RepositoriesContainerApiRepositoriesContainerContainerCopyManifestsRequest {
	return RepositoriesContainerApiRepositoriesContainerContainerCopyManifestsRequest{
		ApiService: a,
		ctx: ctx,
		containerContainerRepositoryHref: containerContainerRepositoryHref,
	}
}

// Execute executes the request
//  @return AsyncOperationResponse
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerCopyManifestsExecute(r RepositoriesContainerApiRepositoriesContainerContainerCopyManifestsRequest) (*AsyncOperationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncOperationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoriesContainerApiService.RepositoriesContainerContainerCopyManifests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{container_container_repository_href}copy_manifests/"
	localVarPath = strings.Replace(localVarPath, "{"+"container_container_repository_href"+"}", url.PathEscape(parameterValueToString(r.containerContainerRepositoryHref, "containerContainerRepositoryHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.manifestCopy == nil {
		return localVarReturnValue, nil, reportError("manifestCopy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.manifestCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RepositoriesContainerApiRepositoriesContainerContainerCopyTagsRequest struct {
	ctx context.Context
	ApiService *RepositoriesContainerApiService
	containerContainerRepositoryHref string
	tagCopy *TagCopy
}

func (r RepositoriesContainerApiRepositoriesContainerContainerCopyTagsRequest) TagCopy(tagCopy TagCopy) RepositoriesContainerApiRepositoriesContainerContainerCopyTagsRequest {
	r.tagCopy = &tagCopy
	return r
}

func (r RepositoriesContainerApiRepositoriesContainerContainerCopyTagsRequest) Execute() (*AsyncOperationResponse, *http.Response, error) {
	return r.ApiService.RepositoriesContainerContainerCopyTagsExecute(r)
}

/*
RepositoriesContainerContainerCopyTags Copy tags

Trigger an asynchronous task to copy tags

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerContainerRepositoryHref
 @return RepositoriesContainerApiRepositoriesContainerContainerCopyTagsRequest
*/
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerCopyTags(ctx context.Context, containerContainerRepositoryHref string) RepositoriesContainerApiRepositoriesContainerContainerCopyTagsRequest {
	return RepositoriesContainerApiRepositoriesContainerContainerCopyTagsRequest{
		ApiService: a,
		ctx: ctx,
		containerContainerRepositoryHref: containerContainerRepositoryHref,
	}
}

// Execute executes the request
//  @return AsyncOperationResponse
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerCopyTagsExecute(r RepositoriesContainerApiRepositoriesContainerContainerCopyTagsRequest) (*AsyncOperationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncOperationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoriesContainerApiService.RepositoriesContainerContainerCopyTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{container_container_repository_href}copy_tags/"
	localVarPath = strings.Replace(localVarPath, "{"+"container_container_repository_href"+"}", url.PathEscape(parameterValueToString(r.containerContainerRepositoryHref, "containerContainerRepositoryHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tagCopy == nil {
		return localVarReturnValue, nil, reportError("tagCopy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagCopy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RepositoriesContainerApiRepositoriesContainerContainerCreateRequest struct {
	ctx context.Context
	ApiService *RepositoriesContainerApiService
	containerContainerRepository *ContainerContainerRepository
}

func (r RepositoriesContainerApiRepositoriesContainerContainerCreateRequest) ContainerContainerRepository(containerContainerRepository ContainerContainerRepository) RepositoriesContainerApiRepositoriesContainerContainerCreateRequest {
	r.containerContainerRepository = &containerContainerRepository
	return r
}

func (r RepositoriesContainerApiRepositoriesContainerContainerCreateRequest) Execute() (*ContainerContainerRepositoryResponse, *http.Response, error) {
	return r.ApiService.RepositoriesContainerContainerCreateExecute(r)
}

/*
RepositoriesContainerContainerCreate Create a container repository

ViewSet for container repo.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RepositoriesContainerApiRepositoriesContainerContainerCreateRequest
*/
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerCreate(ctx context.Context) RepositoriesContainerApiRepositoriesContainerContainerCreateRequest {
	return RepositoriesContainerApiRepositoriesContainerContainerCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ContainerContainerRepositoryResponse
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerCreateExecute(r RepositoriesContainerApiRepositoriesContainerContainerCreateRequest) (*ContainerContainerRepositoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContainerContainerRepositoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoriesContainerApiService.RepositoriesContainerContainerCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/repositories/container/container/"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.containerContainerRepository == nil {
		return localVarReturnValue, nil, reportError("containerContainerRepository is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.containerContainerRepository
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RepositoriesContainerApiRepositoriesContainerContainerDeleteRequest struct {
	ctx context.Context
	ApiService *RepositoriesContainerApiService
	containerContainerRepositoryHref string
}

func (r RepositoriesContainerApiRepositoriesContainerContainerDeleteRequest) Execute() (*AsyncOperationResponse, *http.Response, error) {
	return r.ApiService.RepositoriesContainerContainerDeleteExecute(r)
}

/*
RepositoriesContainerContainerDelete Delete a container repository

Trigger an asynchronous delete task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerContainerRepositoryHref
 @return RepositoriesContainerApiRepositoriesContainerContainerDeleteRequest
*/
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerDelete(ctx context.Context, containerContainerRepositoryHref string) RepositoriesContainerApiRepositoriesContainerContainerDeleteRequest {
	return RepositoriesContainerApiRepositoriesContainerContainerDeleteRequest{
		ApiService: a,
		ctx: ctx,
		containerContainerRepositoryHref: containerContainerRepositoryHref,
	}
}

// Execute executes the request
//  @return AsyncOperationResponse
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerDeleteExecute(r RepositoriesContainerApiRepositoriesContainerContainerDeleteRequest) (*AsyncOperationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncOperationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoriesContainerApiService.RepositoriesContainerContainerDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{container_container_repository_href}"
	localVarPath = strings.Replace(localVarPath, "{"+"container_container_repository_href"+"}", url.PathEscape(parameterValueToString(r.containerContainerRepositoryHref, "containerContainerRepositoryHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RepositoriesContainerApiRepositoriesContainerContainerListRequest struct {
	ctx context.Context
	ApiService *RepositoriesContainerApiService
	limit *int32
	name *string
	nameContains *string
	nameIcontains *string
	nameIn *[]string
	nameStartswith *string
	offset *int32
	ordering *[]string
	pulpLabelSelect *string
	remote *string
	fields *[]string
	excludeFields *[]string
}

// Number of results to return per page.
func (r RepositoriesContainerApiRepositoriesContainerContainerListRequest) Limit(limit int32) RepositoriesContainerApiRepositoriesContainerContainerListRequest {
	r.limit = &limit
	return r
}

// Filter results where name matches value
func (r RepositoriesContainerApiRepositoriesContainerContainerListRequest) Name(name string) RepositoriesContainerApiRepositoriesContainerContainerListRequest {
	r.name = &name
	return r
}

// Filter results where name contains value
func (r RepositoriesContainerApiRepositoriesContainerContainerListRequest) NameContains(nameContains string) RepositoriesContainerApiRepositoriesContainerContainerListRequest {
	r.nameContains = &nameContains
	return r
}

// Filter results where name contains value
func (r RepositoriesContainerApiRepositoriesContainerContainerListRequest) NameIcontains(nameIcontains string) RepositoriesContainerApiRepositoriesContainerContainerListRequest {
	r.nameIcontains = &nameIcontains
	return r
}

// Filter results where name is in a comma-separated list of values
func (r RepositoriesContainerApiRepositoriesContainerContainerListRequest) NameIn(nameIn []string) RepositoriesContainerApiRepositoriesContainerContainerListRequest {
	r.nameIn = &nameIn
	return r
}

// Filter results where name starts with value
func (r RepositoriesContainerApiRepositoriesContainerContainerListRequest) NameStartswith(nameStartswith string) RepositoriesContainerApiRepositoriesContainerContainerListRequest {
	r.nameStartswith = &nameStartswith
	return r
}

// The initial index from which to return the results.
func (r RepositoriesContainerApiRepositoriesContainerContainerListRequest) Offset(offset int32) RepositoriesContainerApiRepositoriesContainerContainerListRequest {
	r.offset = &offset
	return r
}

// Ordering
func (r RepositoriesContainerApiRepositoriesContainerContainerListRequest) Ordering(ordering []string) RepositoriesContainerApiRepositoriesContainerContainerListRequest {
	r.ordering = &ordering
	return r
}

// Filter labels by search string
func (r RepositoriesContainerApiRepositoriesContainerContainerListRequest) PulpLabelSelect(pulpLabelSelect string) RepositoriesContainerApiRepositoriesContainerContainerListRequest {
	r.pulpLabelSelect = &pulpLabelSelect
	return r
}

// Foreign Key referenced by HREF
func (r RepositoriesContainerApiRepositoriesContainerContainerListRequest) Remote(remote string) RepositoriesContainerApiRepositoriesContainerContainerListRequest {
	r.remote = &remote
	return r
}

// A list of fields to include in the response.
func (r RepositoriesContainerApiRepositoriesContainerContainerListRequest) Fields(fields []string) RepositoriesContainerApiRepositoriesContainerContainerListRequest {
	r.fields = &fields
	return r
}

// A list of fields to exclude from the response.
func (r RepositoriesContainerApiRepositoriesContainerContainerListRequest) ExcludeFields(excludeFields []string) RepositoriesContainerApiRepositoriesContainerContainerListRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r RepositoriesContainerApiRepositoriesContainerContainerListRequest) Execute() (*PaginatedcontainerContainerRepositoryResponseList, *http.Response, error) {
	return r.ApiService.RepositoriesContainerContainerListExecute(r)
}

/*
RepositoriesContainerContainerList List container repositorys

ViewSet for container repo.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RepositoriesContainerApiRepositoriesContainerContainerListRequest
*/
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerList(ctx context.Context) RepositoriesContainerApiRepositoriesContainerContainerListRequest {
	return RepositoriesContainerApiRepositoriesContainerContainerListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedcontainerContainerRepositoryResponseList
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerListExecute(r RepositoriesContainerApiRepositoriesContainerContainerListRequest) (*PaginatedcontainerContainerRepositoryResponseList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedcontainerContainerRepositoryResponseList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoriesContainerApiService.RepositoriesContainerContainerList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/repositories/container/container/"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.nameContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__contains", r.nameContains, "")
	}
	if r.nameIcontains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__icontains", r.nameIcontains, "")
	}
	if r.nameIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__in", r.nameIn, "csv")
	}
	if r.nameStartswith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__startswith", r.nameStartswith, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "csv")
	}
	if r.pulpLabelSelect != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pulp_label_select", r.pulpLabelSelect, "")
	}
	if r.remote != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "remote", r.remote, "")
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.excludeFields != nil {
		t := *r.excludeFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RepositoriesContainerApiRepositoriesContainerContainerListRolesRequest struct {
	ctx context.Context
	ApiService *RepositoriesContainerApiService
	containerContainerRepositoryHref string
	fields *[]string
	excludeFields *[]string
}

// A list of fields to include in the response.
func (r RepositoriesContainerApiRepositoriesContainerContainerListRolesRequest) Fields(fields []string) RepositoriesContainerApiRepositoriesContainerContainerListRolesRequest {
	r.fields = &fields
	return r
}

// A list of fields to exclude from the response.
func (r RepositoriesContainerApiRepositoriesContainerContainerListRolesRequest) ExcludeFields(excludeFields []string) RepositoriesContainerApiRepositoriesContainerContainerListRolesRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r RepositoriesContainerApiRepositoriesContainerContainerListRolesRequest) Execute() (*ObjectRolesResponse, *http.Response, error) {
	return r.ApiService.RepositoriesContainerContainerListRolesExecute(r)
}

/*
RepositoriesContainerContainerListRoles Method for RepositoriesContainerContainerListRoles

List roles assigned to this object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerContainerRepositoryHref
 @return RepositoriesContainerApiRepositoriesContainerContainerListRolesRequest
*/
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerListRoles(ctx context.Context, containerContainerRepositoryHref string) RepositoriesContainerApiRepositoriesContainerContainerListRolesRequest {
	return RepositoriesContainerApiRepositoriesContainerContainerListRolesRequest{
		ApiService: a,
		ctx: ctx,
		containerContainerRepositoryHref: containerContainerRepositoryHref,
	}
}

// Execute executes the request
//  @return ObjectRolesResponse
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerListRolesExecute(r RepositoriesContainerApiRepositoriesContainerContainerListRolesRequest) (*ObjectRolesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectRolesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoriesContainerApiService.RepositoriesContainerContainerListRoles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{container_container_repository_href}list_roles/"
	localVarPath = strings.Replace(localVarPath, "{"+"container_container_repository_href"+"}", url.PathEscape(parameterValueToString(r.containerContainerRepositoryHref, "containerContainerRepositoryHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.excludeFields != nil {
		t := *r.excludeFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RepositoriesContainerApiRepositoriesContainerContainerMyPermissionsRequest struct {
	ctx context.Context
	ApiService *RepositoriesContainerApiService
	containerContainerRepositoryHref string
	fields *[]string
	excludeFields *[]string
}

// A list of fields to include in the response.
func (r RepositoriesContainerApiRepositoriesContainerContainerMyPermissionsRequest) Fields(fields []string) RepositoriesContainerApiRepositoriesContainerContainerMyPermissionsRequest {
	r.fields = &fields
	return r
}

// A list of fields to exclude from the response.
func (r RepositoriesContainerApiRepositoriesContainerContainerMyPermissionsRequest) ExcludeFields(excludeFields []string) RepositoriesContainerApiRepositoriesContainerContainerMyPermissionsRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r RepositoriesContainerApiRepositoriesContainerContainerMyPermissionsRequest) Execute() (*MyPermissionsResponse, *http.Response, error) {
	return r.ApiService.RepositoriesContainerContainerMyPermissionsExecute(r)
}

/*
RepositoriesContainerContainerMyPermissions Method for RepositoriesContainerContainerMyPermissions

List permissions available to the current user on this object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerContainerRepositoryHref
 @return RepositoriesContainerApiRepositoriesContainerContainerMyPermissionsRequest
*/
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerMyPermissions(ctx context.Context, containerContainerRepositoryHref string) RepositoriesContainerApiRepositoriesContainerContainerMyPermissionsRequest {
	return RepositoriesContainerApiRepositoriesContainerContainerMyPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		containerContainerRepositoryHref: containerContainerRepositoryHref,
	}
}

// Execute executes the request
//  @return MyPermissionsResponse
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerMyPermissionsExecute(r RepositoriesContainerApiRepositoriesContainerContainerMyPermissionsRequest) (*MyPermissionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MyPermissionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoriesContainerApiService.RepositoriesContainerContainerMyPermissions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{container_container_repository_href}my_permissions/"
	localVarPath = strings.Replace(localVarPath, "{"+"container_container_repository_href"+"}", url.PathEscape(parameterValueToString(r.containerContainerRepositoryHref, "containerContainerRepositoryHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.excludeFields != nil {
		t := *r.excludeFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RepositoriesContainerApiRepositoriesContainerContainerPartialUpdateRequest struct {
	ctx context.Context
	ApiService *RepositoriesContainerApiService
	containerContainerRepositoryHref string
	patchedcontainerContainerRepository *PatchedcontainerContainerRepository
}

func (r RepositoriesContainerApiRepositoriesContainerContainerPartialUpdateRequest) PatchedcontainerContainerRepository(patchedcontainerContainerRepository PatchedcontainerContainerRepository) RepositoriesContainerApiRepositoriesContainerContainerPartialUpdateRequest {
	r.patchedcontainerContainerRepository = &patchedcontainerContainerRepository
	return r
}

func (r RepositoriesContainerApiRepositoriesContainerContainerPartialUpdateRequest) Execute() (*AsyncOperationResponse, *http.Response, error) {
	return r.ApiService.RepositoriesContainerContainerPartialUpdateExecute(r)
}

/*
RepositoriesContainerContainerPartialUpdate Update a container repository

Trigger an asynchronous partial update task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerContainerRepositoryHref
 @return RepositoriesContainerApiRepositoriesContainerContainerPartialUpdateRequest
*/
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerPartialUpdate(ctx context.Context, containerContainerRepositoryHref string) RepositoriesContainerApiRepositoriesContainerContainerPartialUpdateRequest {
	return RepositoriesContainerApiRepositoriesContainerContainerPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		containerContainerRepositoryHref: containerContainerRepositoryHref,
	}
}

// Execute executes the request
//  @return AsyncOperationResponse
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerPartialUpdateExecute(r RepositoriesContainerApiRepositoriesContainerContainerPartialUpdateRequest) (*AsyncOperationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncOperationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoriesContainerApiService.RepositoriesContainerContainerPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{container_container_repository_href}"
	localVarPath = strings.Replace(localVarPath, "{"+"container_container_repository_href"+"}", url.PathEscape(parameterValueToString(r.containerContainerRepositoryHref, "containerContainerRepositoryHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedcontainerContainerRepository == nil {
		return localVarReturnValue, nil, reportError("patchedcontainerContainerRepository is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedcontainerContainerRepository
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RepositoriesContainerApiRepositoriesContainerContainerReadRequest struct {
	ctx context.Context
	ApiService *RepositoriesContainerApiService
	containerContainerRepositoryHref string
	fields *[]string
	excludeFields *[]string
}

// A list of fields to include in the response.
func (r RepositoriesContainerApiRepositoriesContainerContainerReadRequest) Fields(fields []string) RepositoriesContainerApiRepositoriesContainerContainerReadRequest {
	r.fields = &fields
	return r
}

// A list of fields to exclude from the response.
func (r RepositoriesContainerApiRepositoriesContainerContainerReadRequest) ExcludeFields(excludeFields []string) RepositoriesContainerApiRepositoriesContainerContainerReadRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r RepositoriesContainerApiRepositoriesContainerContainerReadRequest) Execute() (*ContainerContainerRepositoryResponse, *http.Response, error) {
	return r.ApiService.RepositoriesContainerContainerReadExecute(r)
}

/*
RepositoriesContainerContainerRead Inspect a container repository

ViewSet for container repo.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerContainerRepositoryHref
 @return RepositoriesContainerApiRepositoriesContainerContainerReadRequest
*/
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerRead(ctx context.Context, containerContainerRepositoryHref string) RepositoriesContainerApiRepositoriesContainerContainerReadRequest {
	return RepositoriesContainerApiRepositoriesContainerContainerReadRequest{
		ApiService: a,
		ctx: ctx,
		containerContainerRepositoryHref: containerContainerRepositoryHref,
	}
}

// Execute executes the request
//  @return ContainerContainerRepositoryResponse
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerReadExecute(r RepositoriesContainerApiRepositoriesContainerContainerReadRequest) (*ContainerContainerRepositoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContainerContainerRepositoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoriesContainerApiService.RepositoriesContainerContainerRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{container_container_repository_href}"
	localVarPath = strings.Replace(localVarPath, "{"+"container_container_repository_href"+"}", url.PathEscape(parameterValueToString(r.containerContainerRepositoryHref, "containerContainerRepositoryHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.excludeFields != nil {
		t := *r.excludeFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RepositoriesContainerApiRepositoriesContainerContainerRemoveRequest struct {
	ctx context.Context
	ApiService *RepositoriesContainerApiService
	containerContainerRepositoryHref string
	recursiveManage *RecursiveManage
}

func (r RepositoriesContainerApiRepositoriesContainerContainerRemoveRequest) RecursiveManage(recursiveManage RecursiveManage) RepositoriesContainerApiRepositoriesContainerContainerRemoveRequest {
	r.recursiveManage = &recursiveManage
	return r
}

func (r RepositoriesContainerApiRepositoriesContainerContainerRemoveRequest) Execute() (*AsyncOperationResponse, *http.Response, error) {
	return r.ApiService.RepositoriesContainerContainerRemoveExecute(r)
}

/*
RepositoriesContainerContainerRemove Remove content

Trigger an async task to recursively remove container content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerContainerRepositoryHref
 @return RepositoriesContainerApiRepositoriesContainerContainerRemoveRequest
*/
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerRemove(ctx context.Context, containerContainerRepositoryHref string) RepositoriesContainerApiRepositoriesContainerContainerRemoveRequest {
	return RepositoriesContainerApiRepositoriesContainerContainerRemoveRequest{
		ApiService: a,
		ctx: ctx,
		containerContainerRepositoryHref: containerContainerRepositoryHref,
	}
}

// Execute executes the request
//  @return AsyncOperationResponse
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerRemoveExecute(r RepositoriesContainerApiRepositoriesContainerContainerRemoveRequest) (*AsyncOperationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncOperationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoriesContainerApiService.RepositoriesContainerContainerRemove")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{container_container_repository_href}remove/"
	localVarPath = strings.Replace(localVarPath, "{"+"container_container_repository_href"+"}", url.PathEscape(parameterValueToString(r.containerContainerRepositoryHref, "containerContainerRepositoryHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.recursiveManage == nil {
		return localVarReturnValue, nil, reportError("recursiveManage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.recursiveManage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RepositoriesContainerApiRepositoriesContainerContainerRemoveRoleRequest struct {
	ctx context.Context
	ApiService *RepositoriesContainerApiService
	containerContainerRepositoryHref string
	nestedRole *NestedRole
}

func (r RepositoriesContainerApiRepositoriesContainerContainerRemoveRoleRequest) NestedRole(nestedRole NestedRole) RepositoriesContainerApiRepositoriesContainerContainerRemoveRoleRequest {
	r.nestedRole = &nestedRole
	return r
}

func (r RepositoriesContainerApiRepositoriesContainerContainerRemoveRoleRequest) Execute() (*NestedRoleResponse, *http.Response, error) {
	return r.ApiService.RepositoriesContainerContainerRemoveRoleExecute(r)
}

/*
RepositoriesContainerContainerRemoveRole Method for RepositoriesContainerContainerRemoveRole

Remove a role for this object from users/groups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerContainerRepositoryHref
 @return RepositoriesContainerApiRepositoriesContainerContainerRemoveRoleRequest
*/
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerRemoveRole(ctx context.Context, containerContainerRepositoryHref string) RepositoriesContainerApiRepositoriesContainerContainerRemoveRoleRequest {
	return RepositoriesContainerApiRepositoriesContainerContainerRemoveRoleRequest{
		ApiService: a,
		ctx: ctx,
		containerContainerRepositoryHref: containerContainerRepositoryHref,
	}
}

// Execute executes the request
//  @return NestedRoleResponse
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerRemoveRoleExecute(r RepositoriesContainerApiRepositoriesContainerContainerRemoveRoleRequest) (*NestedRoleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NestedRoleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoriesContainerApiService.RepositoriesContainerContainerRemoveRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{container_container_repository_href}remove_role/"
	localVarPath = strings.Replace(localVarPath, "{"+"container_container_repository_href"+"}", url.PathEscape(parameterValueToString(r.containerContainerRepositoryHref, "containerContainerRepositoryHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.nestedRole == nil {
		return localVarReturnValue, nil, reportError("nestedRole is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.nestedRole
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RepositoriesContainerApiRepositoriesContainerContainerSignRequest struct {
	ctx context.Context
	ApiService *RepositoriesContainerApiService
	containerContainerRepositoryHref string
	repositorySign *RepositorySign
}

func (r RepositoriesContainerApiRepositoriesContainerContainerSignRequest) RepositorySign(repositorySign RepositorySign) RepositoriesContainerApiRepositoriesContainerContainerSignRequest {
	r.repositorySign = &repositorySign
	return r
}

func (r RepositoriesContainerApiRepositoriesContainerContainerSignRequest) Execute() (*AsyncOperationResponse, *http.Response, error) {
	return r.ApiService.RepositoriesContainerContainerSignExecute(r)
}

/*
RepositoriesContainerContainerSign Sign images in the repo

Trigger an asynchronous task to sign content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerContainerRepositoryHref
 @return RepositoriesContainerApiRepositoriesContainerContainerSignRequest
*/
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerSign(ctx context.Context, containerContainerRepositoryHref string) RepositoriesContainerApiRepositoriesContainerContainerSignRequest {
	return RepositoriesContainerApiRepositoriesContainerContainerSignRequest{
		ApiService: a,
		ctx: ctx,
		containerContainerRepositoryHref: containerContainerRepositoryHref,
	}
}

// Execute executes the request
//  @return AsyncOperationResponse
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerSignExecute(r RepositoriesContainerApiRepositoriesContainerContainerSignRequest) (*AsyncOperationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncOperationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoriesContainerApiService.RepositoriesContainerContainerSign")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{container_container_repository_href}sign/"
	localVarPath = strings.Replace(localVarPath, "{"+"container_container_repository_href"+"}", url.PathEscape(parameterValueToString(r.containerContainerRepositoryHref, "containerContainerRepositoryHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.repositorySign == nil {
		return localVarReturnValue, nil, reportError("repositorySign is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.repositorySign
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RepositoriesContainerApiRepositoriesContainerContainerSyncRequest struct {
	ctx context.Context
	ApiService *RepositoriesContainerApiService
	containerContainerRepositoryHref string
	containerRepositorySyncURL *ContainerRepositorySyncURL
}

func (r RepositoriesContainerApiRepositoriesContainerContainerSyncRequest) ContainerRepositorySyncURL(containerRepositorySyncURL ContainerRepositorySyncURL) RepositoriesContainerApiRepositoriesContainerContainerSyncRequest {
	r.containerRepositorySyncURL = &containerRepositorySyncURL
	return r
}

func (r RepositoriesContainerApiRepositoriesContainerContainerSyncRequest) Execute() (*AsyncOperationResponse, *http.Response, error) {
	return r.ApiService.RepositoriesContainerContainerSyncExecute(r)
}

/*
RepositoriesContainerContainerSync Sync from a remote

Trigger an asynchronous task to sync content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerContainerRepositoryHref
 @return RepositoriesContainerApiRepositoriesContainerContainerSyncRequest
*/
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerSync(ctx context.Context, containerContainerRepositoryHref string) RepositoriesContainerApiRepositoriesContainerContainerSyncRequest {
	return RepositoriesContainerApiRepositoriesContainerContainerSyncRequest{
		ApiService: a,
		ctx: ctx,
		containerContainerRepositoryHref: containerContainerRepositoryHref,
	}
}

// Execute executes the request
//  @return AsyncOperationResponse
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerSyncExecute(r RepositoriesContainerApiRepositoriesContainerContainerSyncRequest) (*AsyncOperationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncOperationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoriesContainerApiService.RepositoriesContainerContainerSync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{container_container_repository_href}sync/"
	localVarPath = strings.Replace(localVarPath, "{"+"container_container_repository_href"+"}", url.PathEscape(parameterValueToString(r.containerContainerRepositoryHref, "containerContainerRepositoryHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.containerRepositorySyncURL == nil {
		return localVarReturnValue, nil, reportError("containerRepositorySyncURL is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.containerRepositorySyncURL
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RepositoriesContainerApiRepositoriesContainerContainerTagRequest struct {
	ctx context.Context
	ApiService *RepositoriesContainerApiService
	containerContainerRepositoryHref string
	tagImage *TagImage
}

func (r RepositoriesContainerApiRepositoriesContainerContainerTagRequest) TagImage(tagImage TagImage) RepositoriesContainerApiRepositoriesContainerContainerTagRequest {
	r.tagImage = &tagImage
	return r
}

func (r RepositoriesContainerApiRepositoriesContainerContainerTagRequest) Execute() (*AsyncOperationResponse, *http.Response, error) {
	return r.ApiService.RepositoriesContainerContainerTagExecute(r)
}

/*
RepositoriesContainerContainerTag Create a Tag

Trigger an asynchronous task to tag an image in the repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerContainerRepositoryHref
 @return RepositoriesContainerApiRepositoriesContainerContainerTagRequest
*/
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerTag(ctx context.Context, containerContainerRepositoryHref string) RepositoriesContainerApiRepositoriesContainerContainerTagRequest {
	return RepositoriesContainerApiRepositoriesContainerContainerTagRequest{
		ApiService: a,
		ctx: ctx,
		containerContainerRepositoryHref: containerContainerRepositoryHref,
	}
}

// Execute executes the request
//  @return AsyncOperationResponse
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerTagExecute(r RepositoriesContainerApiRepositoriesContainerContainerTagRequest) (*AsyncOperationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncOperationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoriesContainerApiService.RepositoriesContainerContainerTag")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{container_container_repository_href}tag/"
	localVarPath = strings.Replace(localVarPath, "{"+"container_container_repository_href"+"}", url.PathEscape(parameterValueToString(r.containerContainerRepositoryHref, "containerContainerRepositoryHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tagImage == nil {
		return localVarReturnValue, nil, reportError("tagImage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagImage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RepositoriesContainerApiRepositoriesContainerContainerUntagRequest struct {
	ctx context.Context
	ApiService *RepositoriesContainerApiService
	containerContainerRepositoryHref string
	unTagImage *UnTagImage
}

func (r RepositoriesContainerApiRepositoriesContainerContainerUntagRequest) UnTagImage(unTagImage UnTagImage) RepositoriesContainerApiRepositoriesContainerContainerUntagRequest {
	r.unTagImage = &unTagImage
	return r
}

func (r RepositoriesContainerApiRepositoriesContainerContainerUntagRequest) Execute() (*AsyncOperationResponse, *http.Response, error) {
	return r.ApiService.RepositoriesContainerContainerUntagExecute(r)
}

/*
RepositoriesContainerContainerUntag Delete a tag

Trigger an asynchronous task to untag an image in the repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerContainerRepositoryHref
 @return RepositoriesContainerApiRepositoriesContainerContainerUntagRequest
*/
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerUntag(ctx context.Context, containerContainerRepositoryHref string) RepositoriesContainerApiRepositoriesContainerContainerUntagRequest {
	return RepositoriesContainerApiRepositoriesContainerContainerUntagRequest{
		ApiService: a,
		ctx: ctx,
		containerContainerRepositoryHref: containerContainerRepositoryHref,
	}
}

// Execute executes the request
//  @return AsyncOperationResponse
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerUntagExecute(r RepositoriesContainerApiRepositoriesContainerContainerUntagRequest) (*AsyncOperationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncOperationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoriesContainerApiService.RepositoriesContainerContainerUntag")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{container_container_repository_href}untag/"
	localVarPath = strings.Replace(localVarPath, "{"+"container_container_repository_href"+"}", url.PathEscape(parameterValueToString(r.containerContainerRepositoryHref, "containerContainerRepositoryHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unTagImage == nil {
		return localVarReturnValue, nil, reportError("unTagImage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unTagImage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RepositoriesContainerApiRepositoriesContainerContainerUpdateRequest struct {
	ctx context.Context
	ApiService *RepositoriesContainerApiService
	containerContainerRepositoryHref string
	containerContainerRepository *ContainerContainerRepository
}

func (r RepositoriesContainerApiRepositoriesContainerContainerUpdateRequest) ContainerContainerRepository(containerContainerRepository ContainerContainerRepository) RepositoriesContainerApiRepositoriesContainerContainerUpdateRequest {
	r.containerContainerRepository = &containerContainerRepository
	return r
}

func (r RepositoriesContainerApiRepositoriesContainerContainerUpdateRequest) Execute() (*AsyncOperationResponse, *http.Response, error) {
	return r.ApiService.RepositoriesContainerContainerUpdateExecute(r)
}

/*
RepositoriesContainerContainerUpdate Update a container repository

Trigger an asynchronous update task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerContainerRepositoryHref
 @return RepositoriesContainerApiRepositoriesContainerContainerUpdateRequest
*/
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerUpdate(ctx context.Context, containerContainerRepositoryHref string) RepositoriesContainerApiRepositoriesContainerContainerUpdateRequest {
	return RepositoriesContainerApiRepositoriesContainerContainerUpdateRequest{
		ApiService: a,
		ctx: ctx,
		containerContainerRepositoryHref: containerContainerRepositoryHref,
	}
}

// Execute executes the request
//  @return AsyncOperationResponse
func (a *RepositoriesContainerApiService) RepositoriesContainerContainerUpdateExecute(r RepositoriesContainerApiRepositoriesContainerContainerUpdateRequest) (*AsyncOperationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncOperationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoriesContainerApiService.RepositoriesContainerContainerUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{container_container_repository_href}"
	localVarPath = strings.Replace(localVarPath, "{"+"container_container_repository_href"+"}", url.PathEscape(parameterValueToString(r.containerContainerRepositoryHref, "containerContainerRepositoryHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.containerContainerRepository == nil {
		return localVarReturnValue, nil, reportError("containerContainerRepository is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.containerContainerRepository
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
