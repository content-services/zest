/*
Pulp 3 API

Fetch, Upload, Organize, and Distribute Software Packages

API version: v3
Contact: pulp-list@redhat.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package zest

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
	"time"
	"reflect"
)


// RemotesPythonAPIService RemotesPythonAPI service
type RemotesPythonAPIService service

type RemotesPythonAPIRemotesPythonPythonAddRoleRequest struct {
	ctx context.Context
	ApiService *RemotesPythonAPIService
	pythonPythonRemoteHref string
	nestedRole *NestedRole
}

func (r RemotesPythonAPIRemotesPythonPythonAddRoleRequest) NestedRole(nestedRole NestedRole) RemotesPythonAPIRemotesPythonPythonAddRoleRequest {
	r.nestedRole = &nestedRole
	return r
}

func (r RemotesPythonAPIRemotesPythonPythonAddRoleRequest) Execute() (*NestedRoleResponse, *http.Response, error) {
	return r.ApiService.RemotesPythonPythonAddRoleExecute(r)
}

/*
RemotesPythonPythonAddRole Add a role

Add a role for this object to users/groups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pythonPythonRemoteHref
 @return RemotesPythonAPIRemotesPythonPythonAddRoleRequest
*/
func (a *RemotesPythonAPIService) RemotesPythonPythonAddRole(ctx context.Context, pythonPythonRemoteHref string) RemotesPythonAPIRemotesPythonPythonAddRoleRequest {
	return RemotesPythonAPIRemotesPythonPythonAddRoleRequest{
		ApiService: a,
		ctx: ctx,
		pythonPythonRemoteHref: pythonPythonRemoteHref,
	}
}

// Execute executes the request
//  @return NestedRoleResponse
func (a *RemotesPythonAPIService) RemotesPythonPythonAddRoleExecute(r RemotesPythonAPIRemotesPythonPythonAddRoleRequest) (*NestedRoleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NestedRoleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemotesPythonAPIService.RemotesPythonPythonAddRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{python_python_remote_href}add_role/"
	localVarPath = strings.Replace(localVarPath, "{"+"python_python_remote_href"+"}", url.PathEscape(parameterValueToString(r.pythonPythonRemoteHref, "pythonPythonRemoteHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.nestedRole == nil {
		return localVarReturnValue, nil, reportError("nestedRole is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.nestedRole
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RemotesPythonAPIRemotesPythonPythonCreateRequest struct {
	ctx context.Context
	ApiService *RemotesPythonAPIService
	pulpDomain string
	pythonPythonRemote *PythonPythonRemote
}

func (r RemotesPythonAPIRemotesPythonPythonCreateRequest) PythonPythonRemote(pythonPythonRemote PythonPythonRemote) RemotesPythonAPIRemotesPythonPythonCreateRequest {
	r.pythonPythonRemote = &pythonPythonRemote
	return r
}

func (r RemotesPythonAPIRemotesPythonPythonCreateRequest) Execute() (*PythonPythonRemoteResponse, *http.Response, error) {
	return r.ApiService.RemotesPythonPythonCreateExecute(r)
}

/*
RemotesPythonPythonCreate Create a python remote

Python Remotes are representations of an external repository of Python content, eg.PyPI.  Fields include upstream repository config. Python Remotes are also used to `sync` fromupstream repositories, and contains sync settings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pulpDomain
 @return RemotesPythonAPIRemotesPythonPythonCreateRequest
*/
func (a *RemotesPythonAPIService) RemotesPythonPythonCreate(ctx context.Context, pulpDomain string) RemotesPythonAPIRemotesPythonPythonCreateRequest {
	return RemotesPythonAPIRemotesPythonPythonCreateRequest{
		ApiService: a,
		ctx: ctx,
		pulpDomain: pulpDomain,
	}
}

// Execute executes the request
//  @return PythonPythonRemoteResponse
func (a *RemotesPythonAPIService) RemotesPythonPythonCreateExecute(r RemotesPythonAPIRemotesPythonPythonCreateRequest) (*PythonPythonRemoteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PythonPythonRemoteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemotesPythonAPIService.RemotesPythonPythonCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/pulp/{pulp_domain}/api/v3/remotes/python/python/"
	localVarPath = strings.Replace(localVarPath, "{"+"pulp_domain"+"}", url.PathEscape(parameterValueToString(r.pulpDomain, "pulpDomain")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pythonPythonRemote == nil {
		return localVarReturnValue, nil, reportError("pythonPythonRemote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pythonPythonRemote
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RemotesPythonAPIRemotesPythonPythonDeleteRequest struct {
	ctx context.Context
	ApiService *RemotesPythonAPIService
	pythonPythonRemoteHref string
}

func (r RemotesPythonAPIRemotesPythonPythonDeleteRequest) Execute() (*AsyncOperationResponse, *http.Response, error) {
	return r.ApiService.RemotesPythonPythonDeleteExecute(r)
}

/*
RemotesPythonPythonDelete Delete a python remote

Trigger an asynchronous delete task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pythonPythonRemoteHref
 @return RemotesPythonAPIRemotesPythonPythonDeleteRequest
*/
func (a *RemotesPythonAPIService) RemotesPythonPythonDelete(ctx context.Context, pythonPythonRemoteHref string) RemotesPythonAPIRemotesPythonPythonDeleteRequest {
	return RemotesPythonAPIRemotesPythonPythonDeleteRequest{
		ApiService: a,
		ctx: ctx,
		pythonPythonRemoteHref: pythonPythonRemoteHref,
	}
}

// Execute executes the request
//  @return AsyncOperationResponse
func (a *RemotesPythonAPIService) RemotesPythonPythonDeleteExecute(r RemotesPythonAPIRemotesPythonPythonDeleteRequest) (*AsyncOperationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncOperationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemotesPythonAPIService.RemotesPythonPythonDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{python_python_remote_href}"
	localVarPath = strings.Replace(localVarPath, "{"+"python_python_remote_href"+"}", url.PathEscape(parameterValueToString(r.pythonPythonRemoteHref, "pythonPythonRemoteHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RemotesPythonAPIRemotesPythonPythonFromBandersnatchRequest struct {
	ctx context.Context
	ApiService *RemotesPythonAPIService
	pulpDomain string
	config *os.File
	name *string
	policy *Policy692Enum
}

// A Bandersnatch config that may be used to construct a Python Remote.
func (r RemotesPythonAPIRemotesPythonPythonFromBandersnatchRequest) Config(config *os.File) RemotesPythonAPIRemotesPythonPythonFromBandersnatchRequest {
	r.config = config
	return r
}

// A unique name for this remote
func (r RemotesPythonAPIRemotesPythonPythonFromBandersnatchRequest) Name(name string) RemotesPythonAPIRemotesPythonPythonFromBandersnatchRequest {
	r.name = &name
	return r
}

// The policy to use when downloading content. The possible values include: &#39;immediate&#39;, &#39;on_demand&#39;, and &#39;streamed&#39;. &#39;on_demand&#39; is the default.* &#x60;immediate&#x60; - When syncing, download all metadata and content now.* &#x60;on_demand&#x60; - When syncing, download metadata, but do not download content now. Instead, download content as clients request it, and save it in Pulp to be served for future client requests.* &#x60;streamed&#x60; - When syncing, download metadata, but do not download content now. Instead,download content as clients request it, but never save it in Pulp. This causes future requests for that same content to have to be downloaded again.
func (r RemotesPythonAPIRemotesPythonPythonFromBandersnatchRequest) Policy(policy Policy692Enum) RemotesPythonAPIRemotesPythonPythonFromBandersnatchRequest {
	r.policy = &policy
	return r
}

func (r RemotesPythonAPIRemotesPythonPythonFromBandersnatchRequest) Execute() (*PythonPythonRemoteResponse, *http.Response, error) {
	return r.ApiService.RemotesPythonPythonFromBandersnatchExecute(r)
}

/*
RemotesPythonPythonFromBandersnatch Create from Bandersnatch

Takes the fields specified in the Bandersnatch config and creates a Python Remote from it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pulpDomain
 @return RemotesPythonAPIRemotesPythonPythonFromBandersnatchRequest
*/
func (a *RemotesPythonAPIService) RemotesPythonPythonFromBandersnatch(ctx context.Context, pulpDomain string) RemotesPythonAPIRemotesPythonPythonFromBandersnatchRequest {
	return RemotesPythonAPIRemotesPythonPythonFromBandersnatchRequest{
		ApiService: a,
		ctx: ctx,
		pulpDomain: pulpDomain,
	}
}

// Execute executes the request
//  @return PythonPythonRemoteResponse
func (a *RemotesPythonAPIService) RemotesPythonPythonFromBandersnatchExecute(r RemotesPythonAPIRemotesPythonPythonFromBandersnatchRequest) (*PythonPythonRemoteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PythonPythonRemoteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemotesPythonAPIService.RemotesPythonPythonFromBandersnatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/pulp/{pulp_domain}/api/v3/remotes/python/python/from_bandersnatch/"
	localVarPath = strings.Replace(localVarPath, "{"+"pulp_domain"+"}", url.PathEscape(parameterValueToString(r.pulpDomain, "pulpDomain")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.config == nil {
		return localVarReturnValue, nil, reportError("config is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if strlen(*r.name) < 1 {
		return localVarReturnValue, nil, reportError("name must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var configLocalVarFormFileName string
	var configLocalVarFileName     string
	var configLocalVarFileBytes    []byte

	configLocalVarFormFileName = "config"


	configLocalVarFile := r.config

	if configLocalVarFile != nil {
		fbs, _ := io.ReadAll(configLocalVarFile)

		configLocalVarFileBytes = fbs
		configLocalVarFileName = configLocalVarFile.Name()
		configLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: configLocalVarFileBytes, fileName: configLocalVarFileName, formFileName: configLocalVarFormFileName})
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	if r.policy != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "policy", r.policy, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RemotesPythonAPIRemotesPythonPythonListRequest struct {
	ctx context.Context
	ApiService *RemotesPythonAPIService
	pulpDomain string
	limit *int32
	name *string
	nameContains *string
	nameIcontains *string
	nameIexact *string
	nameIn *[]string
	nameIregex *string
	nameIstartswith *string
	nameRegex *string
	nameStartswith *string
	offset *int32
	ordering *[]string
	pulpHrefIn *[]string
	pulpIdIn *[]string
	pulpLabelSelect *string
	pulpLastUpdated *time.Time
	pulpLastUpdatedGt *time.Time
	pulpLastUpdatedGte *time.Time
	pulpLastUpdatedLt *time.Time
	pulpLastUpdatedLte *time.Time
	pulpLastUpdatedRange *[]time.Time
	q *string
	fields *[]string
	excludeFields *[]string
}

// Number of results to return per page.
func (r RemotesPythonAPIRemotesPythonPythonListRequest) Limit(limit int32) RemotesPythonAPIRemotesPythonPythonListRequest {
	r.limit = &limit
	return r
}

// Filter results where name matches value
func (r RemotesPythonAPIRemotesPythonPythonListRequest) Name(name string) RemotesPythonAPIRemotesPythonPythonListRequest {
	r.name = &name
	return r
}

// Filter results where name contains value
func (r RemotesPythonAPIRemotesPythonPythonListRequest) NameContains(nameContains string) RemotesPythonAPIRemotesPythonPythonListRequest {
	r.nameContains = &nameContains
	return r
}

// Filter results where name contains value
func (r RemotesPythonAPIRemotesPythonPythonListRequest) NameIcontains(nameIcontains string) RemotesPythonAPIRemotesPythonPythonListRequest {
	r.nameIcontains = &nameIcontains
	return r
}

// Filter results where name matches value
func (r RemotesPythonAPIRemotesPythonPythonListRequest) NameIexact(nameIexact string) RemotesPythonAPIRemotesPythonPythonListRequest {
	r.nameIexact = &nameIexact
	return r
}

// Filter results where name is in a comma-separated list of values
func (r RemotesPythonAPIRemotesPythonPythonListRequest) NameIn(nameIn []string) RemotesPythonAPIRemotesPythonPythonListRequest {
	r.nameIn = &nameIn
	return r
}

// Filter results where name matches regex value
func (r RemotesPythonAPIRemotesPythonPythonListRequest) NameIregex(nameIregex string) RemotesPythonAPIRemotesPythonPythonListRequest {
	r.nameIregex = &nameIregex
	return r
}

// Filter results where name starts with value
func (r RemotesPythonAPIRemotesPythonPythonListRequest) NameIstartswith(nameIstartswith string) RemotesPythonAPIRemotesPythonPythonListRequest {
	r.nameIstartswith = &nameIstartswith
	return r
}

// Filter results where name matches regex value
func (r RemotesPythonAPIRemotesPythonPythonListRequest) NameRegex(nameRegex string) RemotesPythonAPIRemotesPythonPythonListRequest {
	r.nameRegex = &nameRegex
	return r
}

// Filter results where name starts with value
func (r RemotesPythonAPIRemotesPythonPythonListRequest) NameStartswith(nameStartswith string) RemotesPythonAPIRemotesPythonPythonListRequest {
	r.nameStartswith = &nameStartswith
	return r
}

// The initial index from which to return the results.
func (r RemotesPythonAPIRemotesPythonPythonListRequest) Offset(offset int32) RemotesPythonAPIRemotesPythonPythonListRequest {
	r.offset = &offset
	return r
}

// Ordering* &#x60;pulp_id&#x60; - Pulp id* &#x60;-pulp_id&#x60; - Pulp id (descending)* &#x60;pulp_created&#x60; - Pulp created* &#x60;-pulp_created&#x60; - Pulp created (descending)* &#x60;pulp_last_updated&#x60; - Pulp last updated* &#x60;-pulp_last_updated&#x60; - Pulp last updated (descending)* &#x60;pulp_type&#x60; - Pulp type* &#x60;-pulp_type&#x60; - Pulp type (descending)* &#x60;name&#x60; - Name* &#x60;-name&#x60; - Name (descending)* &#x60;pulp_labels&#x60; - Pulp labels* &#x60;-pulp_labels&#x60; - Pulp labels (descending)* &#x60;url&#x60; - Url* &#x60;-url&#x60; - Url (descending)* &#x60;ca_cert&#x60; - Ca cert* &#x60;-ca_cert&#x60; - Ca cert (descending)* &#x60;client_cert&#x60; - Client cert* &#x60;-client_cert&#x60; - Client cert (descending)* &#x60;client_key&#x60; - Client key* &#x60;-client_key&#x60; - Client key (descending)* &#x60;tls_validation&#x60; - Tls validation* &#x60;-tls_validation&#x60; - Tls validation (descending)* &#x60;username&#x60; - Username* &#x60;-username&#x60; - Username (descending)* &#x60;password&#x60; - Password* &#x60;-password&#x60; - Password (descending)* &#x60;proxy_url&#x60; - Proxy url* &#x60;-proxy_url&#x60; - Proxy url (descending)* &#x60;proxy_username&#x60; - Proxy username* &#x60;-proxy_username&#x60; - Proxy username (descending)* &#x60;proxy_password&#x60; - Proxy password* &#x60;-proxy_password&#x60; - Proxy password (descending)* &#x60;download_concurrency&#x60; - Download concurrency* &#x60;-download_concurrency&#x60; - Download concurrency (descending)* &#x60;max_retries&#x60; - Max retries* &#x60;-max_retries&#x60; - Max retries (descending)* &#x60;policy&#x60; - Policy* &#x60;-policy&#x60; - Policy (descending)* &#x60;total_timeout&#x60; - Total timeout* &#x60;-total_timeout&#x60; - Total timeout (descending)* &#x60;connect_timeout&#x60; - Connect timeout* &#x60;-connect_timeout&#x60; - Connect timeout (descending)* &#x60;sock_connect_timeout&#x60; - Sock connect timeout* &#x60;-sock_connect_timeout&#x60; - Sock connect timeout (descending)* &#x60;sock_read_timeout&#x60; - Sock read timeout* &#x60;-sock_read_timeout&#x60; - Sock read timeout (descending)* &#x60;headers&#x60; - Headers* &#x60;-headers&#x60; - Headers (descending)* &#x60;rate_limit&#x60; - Rate limit* &#x60;-rate_limit&#x60; - Rate limit (descending)* &#x60;pk&#x60; - Pk* &#x60;-pk&#x60; - Pk (descending)
func (r RemotesPythonAPIRemotesPythonPythonListRequest) Ordering(ordering []string) RemotesPythonAPIRemotesPythonPythonListRequest {
	r.ordering = &ordering
	return r
}

// Multiple values may be separated by commas.
func (r RemotesPythonAPIRemotesPythonPythonListRequest) PulpHrefIn(pulpHrefIn []string) RemotesPythonAPIRemotesPythonPythonListRequest {
	r.pulpHrefIn = &pulpHrefIn
	return r
}

// Multiple values may be separated by commas.
func (r RemotesPythonAPIRemotesPythonPythonListRequest) PulpIdIn(pulpIdIn []string) RemotesPythonAPIRemotesPythonPythonListRequest {
	r.pulpIdIn = &pulpIdIn
	return r
}

// Filter labels by search string
func (r RemotesPythonAPIRemotesPythonPythonListRequest) PulpLabelSelect(pulpLabelSelect string) RemotesPythonAPIRemotesPythonPythonListRequest {
	r.pulpLabelSelect = &pulpLabelSelect
	return r
}

// Filter results where pulp_last_updated matches value
func (r RemotesPythonAPIRemotesPythonPythonListRequest) PulpLastUpdated(pulpLastUpdated time.Time) RemotesPythonAPIRemotesPythonPythonListRequest {
	r.pulpLastUpdated = &pulpLastUpdated
	return r
}

// Filter results where pulp_last_updated is greater than value
func (r RemotesPythonAPIRemotesPythonPythonListRequest) PulpLastUpdatedGt(pulpLastUpdatedGt time.Time) RemotesPythonAPIRemotesPythonPythonListRequest {
	r.pulpLastUpdatedGt = &pulpLastUpdatedGt
	return r
}

// Filter results where pulp_last_updated is greater than or equal to value
func (r RemotesPythonAPIRemotesPythonPythonListRequest) PulpLastUpdatedGte(pulpLastUpdatedGte time.Time) RemotesPythonAPIRemotesPythonPythonListRequest {
	r.pulpLastUpdatedGte = &pulpLastUpdatedGte
	return r
}

// Filter results where pulp_last_updated is less than value
func (r RemotesPythonAPIRemotesPythonPythonListRequest) PulpLastUpdatedLt(pulpLastUpdatedLt time.Time) RemotesPythonAPIRemotesPythonPythonListRequest {
	r.pulpLastUpdatedLt = &pulpLastUpdatedLt
	return r
}

// Filter results where pulp_last_updated is less than or equal to value
func (r RemotesPythonAPIRemotesPythonPythonListRequest) PulpLastUpdatedLte(pulpLastUpdatedLte time.Time) RemotesPythonAPIRemotesPythonPythonListRequest {
	r.pulpLastUpdatedLte = &pulpLastUpdatedLte
	return r
}

// Filter results where pulp_last_updated is between two comma separated values
func (r RemotesPythonAPIRemotesPythonPythonListRequest) PulpLastUpdatedRange(pulpLastUpdatedRange []time.Time) RemotesPythonAPIRemotesPythonPythonListRequest {
	r.pulpLastUpdatedRange = &pulpLastUpdatedRange
	return r
}

// Filter results by using NOT, AND and OR operations on other filters
func (r RemotesPythonAPIRemotesPythonPythonListRequest) Q(q string) RemotesPythonAPIRemotesPythonPythonListRequest {
	r.q = &q
	return r
}

// A list of fields to include in the response.
func (r RemotesPythonAPIRemotesPythonPythonListRequest) Fields(fields []string) RemotesPythonAPIRemotesPythonPythonListRequest {
	r.fields = &fields
	return r
}

// A list of fields to exclude from the response.
func (r RemotesPythonAPIRemotesPythonPythonListRequest) ExcludeFields(excludeFields []string) RemotesPythonAPIRemotesPythonPythonListRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r RemotesPythonAPIRemotesPythonPythonListRequest) Execute() (*PaginatedpythonPythonRemoteResponseList, *http.Response, error) {
	return r.ApiService.RemotesPythonPythonListExecute(r)
}

/*
RemotesPythonPythonList List python remotes

Python Remotes are representations of an external repository of Python content, eg.PyPI.  Fields include upstream repository config. Python Remotes are also used to `sync` fromupstream repositories, and contains sync settings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pulpDomain
 @return RemotesPythonAPIRemotesPythonPythonListRequest
*/
func (a *RemotesPythonAPIService) RemotesPythonPythonList(ctx context.Context, pulpDomain string) RemotesPythonAPIRemotesPythonPythonListRequest {
	return RemotesPythonAPIRemotesPythonPythonListRequest{
		ApiService: a,
		ctx: ctx,
		pulpDomain: pulpDomain,
	}
}

// Execute executes the request
//  @return PaginatedpythonPythonRemoteResponseList
func (a *RemotesPythonAPIService) RemotesPythonPythonListExecute(r RemotesPythonAPIRemotesPythonPythonListRequest) (*PaginatedpythonPythonRemoteResponseList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedpythonPythonRemoteResponseList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemotesPythonAPIService.RemotesPythonPythonList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/pulp/{pulp_domain}/api/v3/remotes/python/python/"
	localVarPath = strings.Replace(localVarPath, "{"+"pulp_domain"+"}", url.PathEscape(parameterValueToString(r.pulpDomain, "pulpDomain")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.nameContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__contains", r.nameContains, "form", "")
	}
	if r.nameIcontains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__icontains", r.nameIcontains, "form", "")
	}
	if r.nameIexact != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__iexact", r.nameIexact, "form", "")
	}
	if r.nameIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__in", r.nameIn, "form", "csv")
	}
	if r.nameIregex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__iregex", r.nameIregex, "form", "")
	}
	if r.nameIstartswith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__istartswith", r.nameIstartswith, "form", "")
	}
	if r.nameRegex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__regex", r.nameRegex, "form", "")
	}
	if r.nameStartswith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__startswith", r.nameStartswith, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "csv")
	}
	if r.pulpHrefIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pulp_href__in", r.pulpHrefIn, "form", "csv")
	}
	if r.pulpIdIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pulp_id__in", r.pulpIdIn, "form", "csv")
	}
	if r.pulpLabelSelect != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pulp_label_select", r.pulpLabelSelect, "form", "")
	}
	if r.pulpLastUpdated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pulp_last_updated", r.pulpLastUpdated, "form", "")
	}
	if r.pulpLastUpdatedGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pulp_last_updated__gt", r.pulpLastUpdatedGt, "form", "")
	}
	if r.pulpLastUpdatedGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pulp_last_updated__gte", r.pulpLastUpdatedGte, "form", "")
	}
	if r.pulpLastUpdatedLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pulp_last_updated__lt", r.pulpLastUpdatedLt, "form", "")
	}
	if r.pulpLastUpdatedLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pulp_last_updated__lte", r.pulpLastUpdatedLte, "form", "")
	}
	if r.pulpLastUpdatedRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pulp_last_updated__range", r.pulpLastUpdatedRange, "form", "csv")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
                               parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.excludeFields != nil {
		t := *r.excludeFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
                               parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RemotesPythonAPIRemotesPythonPythonListRolesRequest struct {
	ctx context.Context
	ApiService *RemotesPythonAPIService
	pythonPythonRemoteHref string
	fields *[]string
	excludeFields *[]string
}

// A list of fields to include in the response.
func (r RemotesPythonAPIRemotesPythonPythonListRolesRequest) Fields(fields []string) RemotesPythonAPIRemotesPythonPythonListRolesRequest {
	r.fields = &fields
	return r
}

// A list of fields to exclude from the response.
func (r RemotesPythonAPIRemotesPythonPythonListRolesRequest) ExcludeFields(excludeFields []string) RemotesPythonAPIRemotesPythonPythonListRolesRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r RemotesPythonAPIRemotesPythonPythonListRolesRequest) Execute() (*ObjectRolesResponse, *http.Response, error) {
	return r.ApiService.RemotesPythonPythonListRolesExecute(r)
}

/*
RemotesPythonPythonListRoles List roles

List roles assigned to this object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pythonPythonRemoteHref
 @return RemotesPythonAPIRemotesPythonPythonListRolesRequest
*/
func (a *RemotesPythonAPIService) RemotesPythonPythonListRoles(ctx context.Context, pythonPythonRemoteHref string) RemotesPythonAPIRemotesPythonPythonListRolesRequest {
	return RemotesPythonAPIRemotesPythonPythonListRolesRequest{
		ApiService: a,
		ctx: ctx,
		pythonPythonRemoteHref: pythonPythonRemoteHref,
	}
}

// Execute executes the request
//  @return ObjectRolesResponse
func (a *RemotesPythonAPIService) RemotesPythonPythonListRolesExecute(r RemotesPythonAPIRemotesPythonPythonListRolesRequest) (*ObjectRolesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectRolesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemotesPythonAPIService.RemotesPythonPythonListRoles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{python_python_remote_href}list_roles/"
	localVarPath = strings.Replace(localVarPath, "{"+"python_python_remote_href"+"}", url.PathEscape(parameterValueToString(r.pythonPythonRemoteHref, "pythonPythonRemoteHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
                               parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.excludeFields != nil {
		t := *r.excludeFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
                               parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RemotesPythonAPIRemotesPythonPythonMyPermissionsRequest struct {
	ctx context.Context
	ApiService *RemotesPythonAPIService
	pythonPythonRemoteHref string
	fields *[]string
	excludeFields *[]string
}

// A list of fields to include in the response.
func (r RemotesPythonAPIRemotesPythonPythonMyPermissionsRequest) Fields(fields []string) RemotesPythonAPIRemotesPythonPythonMyPermissionsRequest {
	r.fields = &fields
	return r
}

// A list of fields to exclude from the response.
func (r RemotesPythonAPIRemotesPythonPythonMyPermissionsRequest) ExcludeFields(excludeFields []string) RemotesPythonAPIRemotesPythonPythonMyPermissionsRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r RemotesPythonAPIRemotesPythonPythonMyPermissionsRequest) Execute() (*MyPermissionsResponse, *http.Response, error) {
	return r.ApiService.RemotesPythonPythonMyPermissionsExecute(r)
}

/*
RemotesPythonPythonMyPermissions List user permissions

List permissions available to the current user on this object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pythonPythonRemoteHref
 @return RemotesPythonAPIRemotesPythonPythonMyPermissionsRequest
*/
func (a *RemotesPythonAPIService) RemotesPythonPythonMyPermissions(ctx context.Context, pythonPythonRemoteHref string) RemotesPythonAPIRemotesPythonPythonMyPermissionsRequest {
	return RemotesPythonAPIRemotesPythonPythonMyPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		pythonPythonRemoteHref: pythonPythonRemoteHref,
	}
}

// Execute executes the request
//  @return MyPermissionsResponse
func (a *RemotesPythonAPIService) RemotesPythonPythonMyPermissionsExecute(r RemotesPythonAPIRemotesPythonPythonMyPermissionsRequest) (*MyPermissionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MyPermissionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemotesPythonAPIService.RemotesPythonPythonMyPermissions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{python_python_remote_href}my_permissions/"
	localVarPath = strings.Replace(localVarPath, "{"+"python_python_remote_href"+"}", url.PathEscape(parameterValueToString(r.pythonPythonRemoteHref, "pythonPythonRemoteHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
                               parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.excludeFields != nil {
		t := *r.excludeFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
                               parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RemotesPythonAPIRemotesPythonPythonPartialUpdateRequest struct {
	ctx context.Context
	ApiService *RemotesPythonAPIService
	pythonPythonRemoteHref string
	patchedpythonPythonRemote *PatchedpythonPythonRemote
}

func (r RemotesPythonAPIRemotesPythonPythonPartialUpdateRequest) PatchedpythonPythonRemote(patchedpythonPythonRemote PatchedpythonPythonRemote) RemotesPythonAPIRemotesPythonPythonPartialUpdateRequest {
	r.patchedpythonPythonRemote = &patchedpythonPythonRemote
	return r
}

func (r RemotesPythonAPIRemotesPythonPythonPartialUpdateRequest) Execute() (*AsyncOperationResponse, *http.Response, error) {
	return r.ApiService.RemotesPythonPythonPartialUpdateExecute(r)
}

/*
RemotesPythonPythonPartialUpdate Update a python remote

Trigger an asynchronous partial update task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pythonPythonRemoteHref
 @return RemotesPythonAPIRemotesPythonPythonPartialUpdateRequest
*/
func (a *RemotesPythonAPIService) RemotesPythonPythonPartialUpdate(ctx context.Context, pythonPythonRemoteHref string) RemotesPythonAPIRemotesPythonPythonPartialUpdateRequest {
	return RemotesPythonAPIRemotesPythonPythonPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		pythonPythonRemoteHref: pythonPythonRemoteHref,
	}
}

// Execute executes the request
//  @return AsyncOperationResponse
func (a *RemotesPythonAPIService) RemotesPythonPythonPartialUpdateExecute(r RemotesPythonAPIRemotesPythonPythonPartialUpdateRequest) (*AsyncOperationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncOperationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemotesPythonAPIService.RemotesPythonPythonPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{python_python_remote_href}"
	localVarPath = strings.Replace(localVarPath, "{"+"python_python_remote_href"+"}", url.PathEscape(parameterValueToString(r.pythonPythonRemoteHref, "pythonPythonRemoteHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedpythonPythonRemote == nil {
		return localVarReturnValue, nil, reportError("patchedpythonPythonRemote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedpythonPythonRemote
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RemotesPythonAPIRemotesPythonPythonReadRequest struct {
	ctx context.Context
	ApiService *RemotesPythonAPIService
	pythonPythonRemoteHref string
	fields *[]string
	excludeFields *[]string
}

// A list of fields to include in the response.
func (r RemotesPythonAPIRemotesPythonPythonReadRequest) Fields(fields []string) RemotesPythonAPIRemotesPythonPythonReadRequest {
	r.fields = &fields
	return r
}

// A list of fields to exclude from the response.
func (r RemotesPythonAPIRemotesPythonPythonReadRequest) ExcludeFields(excludeFields []string) RemotesPythonAPIRemotesPythonPythonReadRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r RemotesPythonAPIRemotesPythonPythonReadRequest) Execute() (*PythonPythonRemoteResponse, *http.Response, error) {
	return r.ApiService.RemotesPythonPythonReadExecute(r)
}

/*
RemotesPythonPythonRead Inspect a python remote

Python Remotes are representations of an external repository of Python content, eg.PyPI.  Fields include upstream repository config. Python Remotes are also used to `sync` fromupstream repositories, and contains sync settings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pythonPythonRemoteHref
 @return RemotesPythonAPIRemotesPythonPythonReadRequest
*/
func (a *RemotesPythonAPIService) RemotesPythonPythonRead(ctx context.Context, pythonPythonRemoteHref string) RemotesPythonAPIRemotesPythonPythonReadRequest {
	return RemotesPythonAPIRemotesPythonPythonReadRequest{
		ApiService: a,
		ctx: ctx,
		pythonPythonRemoteHref: pythonPythonRemoteHref,
	}
}

// Execute executes the request
//  @return PythonPythonRemoteResponse
func (a *RemotesPythonAPIService) RemotesPythonPythonReadExecute(r RemotesPythonAPIRemotesPythonPythonReadRequest) (*PythonPythonRemoteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PythonPythonRemoteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemotesPythonAPIService.RemotesPythonPythonRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{python_python_remote_href}"
	localVarPath = strings.Replace(localVarPath, "{"+"python_python_remote_href"+"}", url.PathEscape(parameterValueToString(r.pythonPythonRemoteHref, "pythonPythonRemoteHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
                               parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.excludeFields != nil {
		t := *r.excludeFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
                               parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RemotesPythonAPIRemotesPythonPythonRemoveRoleRequest struct {
	ctx context.Context
	ApiService *RemotesPythonAPIService
	pythonPythonRemoteHref string
	nestedRole *NestedRole
}

func (r RemotesPythonAPIRemotesPythonPythonRemoveRoleRequest) NestedRole(nestedRole NestedRole) RemotesPythonAPIRemotesPythonPythonRemoveRoleRequest {
	r.nestedRole = &nestedRole
	return r
}

func (r RemotesPythonAPIRemotesPythonPythonRemoveRoleRequest) Execute() (*NestedRoleResponse, *http.Response, error) {
	return r.ApiService.RemotesPythonPythonRemoveRoleExecute(r)
}

/*
RemotesPythonPythonRemoveRole Remove a role

Remove a role for this object from users/groups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pythonPythonRemoteHref
 @return RemotesPythonAPIRemotesPythonPythonRemoveRoleRequest
*/
func (a *RemotesPythonAPIService) RemotesPythonPythonRemoveRole(ctx context.Context, pythonPythonRemoteHref string) RemotesPythonAPIRemotesPythonPythonRemoveRoleRequest {
	return RemotesPythonAPIRemotesPythonPythonRemoveRoleRequest{
		ApiService: a,
		ctx: ctx,
		pythonPythonRemoteHref: pythonPythonRemoteHref,
	}
}

// Execute executes the request
//  @return NestedRoleResponse
func (a *RemotesPythonAPIService) RemotesPythonPythonRemoveRoleExecute(r RemotesPythonAPIRemotesPythonPythonRemoveRoleRequest) (*NestedRoleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NestedRoleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemotesPythonAPIService.RemotesPythonPythonRemoveRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{python_python_remote_href}remove_role/"
	localVarPath = strings.Replace(localVarPath, "{"+"python_python_remote_href"+"}", url.PathEscape(parameterValueToString(r.pythonPythonRemoteHref, "pythonPythonRemoteHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.nestedRole == nil {
		return localVarReturnValue, nil, reportError("nestedRole is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.nestedRole
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RemotesPythonAPIRemotesPythonPythonSetLabelRequest struct {
	ctx context.Context
	ApiService *RemotesPythonAPIService
	pythonPythonRemoteHref string
	setLabel *SetLabel
}

func (r RemotesPythonAPIRemotesPythonPythonSetLabelRequest) SetLabel(setLabel SetLabel) RemotesPythonAPIRemotesPythonPythonSetLabelRequest {
	r.setLabel = &setLabel
	return r
}

func (r RemotesPythonAPIRemotesPythonPythonSetLabelRequest) Execute() (*SetLabelResponse, *http.Response, error) {
	return r.ApiService.RemotesPythonPythonSetLabelExecute(r)
}

/*
RemotesPythonPythonSetLabel Set a label

Set a single pulp_label on the object to a specific value or null.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pythonPythonRemoteHref
 @return RemotesPythonAPIRemotesPythonPythonSetLabelRequest
*/
func (a *RemotesPythonAPIService) RemotesPythonPythonSetLabel(ctx context.Context, pythonPythonRemoteHref string) RemotesPythonAPIRemotesPythonPythonSetLabelRequest {
	return RemotesPythonAPIRemotesPythonPythonSetLabelRequest{
		ApiService: a,
		ctx: ctx,
		pythonPythonRemoteHref: pythonPythonRemoteHref,
	}
}

// Execute executes the request
//  @return SetLabelResponse
func (a *RemotesPythonAPIService) RemotesPythonPythonSetLabelExecute(r RemotesPythonAPIRemotesPythonPythonSetLabelRequest) (*SetLabelResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetLabelResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemotesPythonAPIService.RemotesPythonPythonSetLabel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{python_python_remote_href}set_label/"
	localVarPath = strings.Replace(localVarPath, "{"+"python_python_remote_href"+"}", url.PathEscape(parameterValueToString(r.pythonPythonRemoteHref, "pythonPythonRemoteHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.setLabel == nil {
		return localVarReturnValue, nil, reportError("setLabel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setLabel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RemotesPythonAPIRemotesPythonPythonUnsetLabelRequest struct {
	ctx context.Context
	ApiService *RemotesPythonAPIService
	pythonPythonRemoteHref string
	unsetLabel *UnsetLabel
}

func (r RemotesPythonAPIRemotesPythonPythonUnsetLabelRequest) UnsetLabel(unsetLabel UnsetLabel) RemotesPythonAPIRemotesPythonPythonUnsetLabelRequest {
	r.unsetLabel = &unsetLabel
	return r
}

func (r RemotesPythonAPIRemotesPythonPythonUnsetLabelRequest) Execute() (*UnsetLabelResponse, *http.Response, error) {
	return r.ApiService.RemotesPythonPythonUnsetLabelExecute(r)
}

/*
RemotesPythonPythonUnsetLabel Unset a label

Unset a single pulp_label on the object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pythonPythonRemoteHref
 @return RemotesPythonAPIRemotesPythonPythonUnsetLabelRequest
*/
func (a *RemotesPythonAPIService) RemotesPythonPythonUnsetLabel(ctx context.Context, pythonPythonRemoteHref string) RemotesPythonAPIRemotesPythonPythonUnsetLabelRequest {
	return RemotesPythonAPIRemotesPythonPythonUnsetLabelRequest{
		ApiService: a,
		ctx: ctx,
		pythonPythonRemoteHref: pythonPythonRemoteHref,
	}
}

// Execute executes the request
//  @return UnsetLabelResponse
func (a *RemotesPythonAPIService) RemotesPythonPythonUnsetLabelExecute(r RemotesPythonAPIRemotesPythonPythonUnsetLabelRequest) (*UnsetLabelResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UnsetLabelResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemotesPythonAPIService.RemotesPythonPythonUnsetLabel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{python_python_remote_href}unset_label/"
	localVarPath = strings.Replace(localVarPath, "{"+"python_python_remote_href"+"}", url.PathEscape(parameterValueToString(r.pythonPythonRemoteHref, "pythonPythonRemoteHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unsetLabel == nil {
		return localVarReturnValue, nil, reportError("unsetLabel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unsetLabel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RemotesPythonAPIRemotesPythonPythonUpdateRequest struct {
	ctx context.Context
	ApiService *RemotesPythonAPIService
	pythonPythonRemoteHref string
	pythonPythonRemote *PythonPythonRemote
}

func (r RemotesPythonAPIRemotesPythonPythonUpdateRequest) PythonPythonRemote(pythonPythonRemote PythonPythonRemote) RemotesPythonAPIRemotesPythonPythonUpdateRequest {
	r.pythonPythonRemote = &pythonPythonRemote
	return r
}

func (r RemotesPythonAPIRemotesPythonPythonUpdateRequest) Execute() (*AsyncOperationResponse, *http.Response, error) {
	return r.ApiService.RemotesPythonPythonUpdateExecute(r)
}

/*
RemotesPythonPythonUpdate Update a python remote

Trigger an asynchronous update task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pythonPythonRemoteHref
 @return RemotesPythonAPIRemotesPythonPythonUpdateRequest
*/
func (a *RemotesPythonAPIService) RemotesPythonPythonUpdate(ctx context.Context, pythonPythonRemoteHref string) RemotesPythonAPIRemotesPythonPythonUpdateRequest {
	return RemotesPythonAPIRemotesPythonPythonUpdateRequest{
		ApiService: a,
		ctx: ctx,
		pythonPythonRemoteHref: pythonPythonRemoteHref,
	}
}

// Execute executes the request
//  @return AsyncOperationResponse
func (a *RemotesPythonAPIService) RemotesPythonPythonUpdateExecute(r RemotesPythonAPIRemotesPythonPythonUpdateRequest) (*AsyncOperationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncOperationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemotesPythonAPIService.RemotesPythonPythonUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{python_python_remote_href}"
	localVarPath = strings.Replace(localVarPath, "{"+"python_python_remote_href"+"}", url.PathEscape(parameterValueToString(r.pythonPythonRemoteHref, "pythonPythonRemoteHref")), -1)
        localVarPath = strings.Replace(localVarPath, "/%2F", "/", -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pythonPythonRemote == nil {
		return localVarReturnValue, nil, reportError("pythonPythonRemote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pythonPythonRemote
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
